<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHERPA-ZARIC</title>
  
  <subtitle>在神秘的珠穆朗玛峰，有一个为世界各国登山队充当向导与挑夫的族群——夏尔巴人 （SHERPA）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-12T14:48:19.662Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZARIC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis知识点总结</title>
    <link href="http://yoursite.com/2019/11/12/redis/"/>
    <id>http://yoursite.com/2019/11/12/redis/</id>
    <published>2019-11-12T14:24:38.000Z</published>
    <updated>2019-11-12T14:48:19.662Z</updated>
    
    <content type="html"><![CDATA[<p>探讨问题点：</p><blockquote><p>缓存的使用场景</p><p>redis使用</p><p>缓存使用中的坑</p></blockquote><h2 id="为什么要使用缓存？使用场景"><a href="#为什么要使用缓存？使用场景" class="headerlink" title="为什么要使用缓存？使用场景"></a>为什么要使用缓存？使用场景</h2><p>redis&amp; memcached</p><ul><li>大幅度缓解关系型数据库并发访问的压力：热点数据</li><li>减少相应时间：内存IO速度比磁盘快。</li><li>提升吞吐量：redis等内存数据库单机就可以支持很大的并发。</li></ul><p><img src="/images/io%E6%97%B6%E9%97%B4%E5%AF%B9%E6%AF%94.jpg" alt=""></p><h2 id="redis常用数据类型，使用方式"><a href="#redis常用数据类型，使用方式" class="headerlink" title="redis常用数据类型，使用方式"></a>redis常用数据类型，使用方式</h2><p>redis常用数据类型：</p><ul><li>string  </li><li>list 双向链表</li><li>hash表， hset key value</li><li>set 集合，用户关注着</li><li>sorted set 有序集合，实时信息排行榜</li></ul><p>redis内置实现方式：</p><p>底层使用c语言实现。图书参考 redis设计与实现</p><ul><li><p>string 整数或者sds</p></li><li><p>list ziplist 或者double linked list<br>  ziplist使用连续的内存块存储数据，节省内存</p></li><li><p>set  intset 或者hashtable</p></li><li><p>sortedset skiplist 跳跃表</p></li></ul><p>跳跃表是什么？为什么不适用平衡树？</p><h2 id="缓存使用问题：数据一致性；缓存穿透、击穿、雪崩问题"><a href="#缓存使用问题：数据一致性；缓存穿透、击穿、雪崩问题" class="headerlink" title="缓存使用问题：数据一致性；缓存穿透、击穿、雪崩问题"></a>缓存使用问题：数据一致性；缓存穿透、击穿、雪崩问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;探讨问题点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓存的使用场景&lt;/p&gt;
&lt;p&gt;redis使用&lt;/p&gt;
&lt;p&gt;缓存使用中的坑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么要使用缓存？使用场景&quot;&gt;&lt;a href=&quot;#为什么要使用缓存？使用场景&quot; class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python_variable_scope</title>
    <link href="http://yoursite.com/2019/11/06/python_variable_scope/"/>
    <id>http://yoursite.com/2019/11/06/python_variable_scope/</id>
    <published>2019-11-06T15:43:26.398Z</published>
    <updated>2019-11-06T15:43:26.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中的变量范围"><a href="#Python中的变量范围" class="headerlink" title="Python中的变量范围"></a>Python中的变量范围</h2><blockquote><p>关于变量的讨论虽然有很多博客，但是感觉大多数都没有深度，浅尝辄止。推荐一本书《流畅的python》<br>在第八章，对 对象的引用、可变性和垃圾回收有很详细和深度的讲解。我在这里也通过搜索的一些文章和这本书的<br>内容谈谈自己的见解，顺便也做一下笔记。</p></blockquote><p>如果您熟悉Python或任何其他编程语言，<br>你肯定会知道必须先定义变量，然后才能在程序中使用它们。<br>根据定义的方式和位置，必须以不同的方式访问变量。<br>有些变量是全局定义的，有些是局部定义的。<br>这意味着引用程序某个部分中的实体的变量，可能引用程序另一部分中的不同内容。</p><h2 id="到底是什么变量？"><a href="#到底是什么变量？" class="headerlink" title="到底是什么变量？"></a>到底是什么变量？</h2><p>要了解变量的范围，重要的是首先了解什么是变量。本质上，它们是内存中对象的引用或指针。将变量分配给=实例时，<br>就是将变量绑定（或映射）到该实例。<br>可以将多个变量绑定到同一实例。<br>Python使用名称空间跟踪所有这些映射。<br>这些是用于将变量名映射到对象的容器。你可以将它们视为包含name:object映射的字典。<br>可以通过选择分配给它们的名称访问对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = a</span><br><span class="line">a = 3</span><br></pre></td></tr></table></figure><p>在上面得实例中，a首先绑定到整数5。在这种情况下，a是变量名，整数5是对象<br>然后b设置为a。这实际上意味着b现在绑定到与a相同得整数值5.</p><p>如果随后把a改为4，有过这样经历得同学可能会认为b也会是3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = b = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; a[1] = 0</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 0, 3]</span><br></pre></td></tr></table></figure><p>值得注意的是 字符串、字节、和数字 等单一型序列是扁平的，它们保存的<br>不是引用，而是在链序的内存中保存数据本身。</p><p>未完待续….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python中的变量范围&quot;&gt;&lt;a href=&quot;#Python中的变量范围&quot; class=&quot;headerlink&quot; title=&quot;Python中的变量范围&quot;&gt;&lt;/a&gt;Python中的变量范围&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关于变量的讨论虽然有很多博客，但是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库优化设计方法初探</title>
    <link href="http://yoursite.com/2019/11/06/sql-index-condition-md/"/>
    <id>http://yoursite.com/2019/11/06/sql-index-condition-md/</id>
    <published>2019-11-06T15:02:12.502Z</published>
    <updated>2019-11-06T15:02:12.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库优化设计方法初探"><a href="#数据库优化设计方法初探" class="headerlink" title="数据库优化设计方法初探"></a>数据库优化设计方法初探</h2><p>随着数据库技术的发展，人们越来越依赖于计<br>算机化的业务数据。但由于传统的基于文件的数据<br>存储和检索方法不灵活且难于管理，因而数据库优<br>化设计成为人们关注的问题。如何有效地组织和处<br>理大型数据库的海量数据，使得人们能方便、准确、<br>快捷地完成对数据的存取操作，成为对数据库的建<br>设及使用的瓶颈。</p><p>运行速度及执行效率是衡量数据库系统性能的<br>重要标准，为了保证系统性能和吞吐量，需要对数据<br>库的逻辑设计和物理设计进行优化，并贯穿于数据库设计的始终，这就是数据库优化设计的首要任务。<br>本文从范式优化、索引优化、表的优化及查询优化四<br>个方面探讨数据库优化设计的方法，并对它们的综<br>合使用进行分析。</p><h3 id="1范式优化"><a href="#1范式优化" class="headerlink" title="1范式优化"></a>1范式优化</h3><p>数据库逻辑设计的结果不是惟一的，好的关系<br>模式通常需要满足2个条件：正确表达数据语义和<br>避免数据冗余、异常及不一致问题的出现。设计过程<br>中，要从这2个基本条件出发，不要顾此失彼，这样<br>才能在提高数据库性能的同时保证数据库的正确<br>性。<br>将模式的范式作为评价关系模式优劣的标准具<br>有一定的科学性。通常一个关系模式达到BCNF或<br>3NF时，被认为具有较好的性能。当某关系模式达到BCNF时，可以有效消除数据冗余和异常现象，<br>但有时不一定保持原关系模式的函数依赖关系，破<br>坏了数据语义。因此在设计时应统筹兼顾，先尽可能<br>设计成BCNF模式集，若此时达不到保持函数依赖<br>的特点，则降低范式要求，改成3NF模式集，以保证<br>模式集正确地表达数据语义。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>索引是数据库中重要的数据结构，它的根本目<br>的是为了提高查询效率，改善系统性能。但对索引的<br>存储和维护操作的同时会给系统的空间和时间上带<br>来一些负面影响，牺牲一定的系统性能。因此设计时<br>应尽量选择有用的索引，在提高查询速度和节省存<br>储空间之间寻求最佳的平衡点：</p><p>(1)在大型关系数据库中，若处理的关系表较<br>小，则无需建立索引。因为数据量较小时，直接扫描<br>便可很快遍历整个表，建立索引反而会加重系统负<br>担。</p><p>(2)如果数据的更新比较频繁，维护索引所付出<br>的代价则很大，若这种代价超出了查询上所获得的<br>好处，此时索引不可取。</p><p>(3)选择合适的列建立索引对平衡索引的正负<br>面影响有重要作用。通常在有如下特性的数据列建<br>立索引：</p><pre><code>①定义有主键和外键的数据列；②需要在指定范围中快速或频繁查询的列；③需要按排序顺序快速或频繁检索的列；④在集合过程中需要快速或频繁组合到一起的列。</code></pre><p>如有下列情况时则不考虑创建索引L2]：</p><pre><code>①在查询中几乎不涉及的列；②不同值少的列，比如在学生表的“性别”列上只有“男”与“女”2个不同值，就无必要建立索引；③由文本、图像等数据类型定义的列。</code></pre><p>(4)索引分为聚集索引和非聚集索引，建立索引时，应考虑对两者的选择：</p><pre><code>①经常作为查询结果排序条件的字段应建为聚集索引。例如查询结果要对年龄排序，可在年龄字段上建立聚集索引；②当以某字段为查询条件，需要回传局部范围的大量数据时，应在此字段上建立聚集索引，而当查询所获得的数据量较少时，有必要在此字段上建立非聚集索引。例如回传某个时间段之间的数据，可考虑在日期字段上建聚集索引；③应在内容重复性较大的字段上建立聚集索引，而当某字段的数据惟一性较高时，有必要建立非聚集索引。例如学生的成绩重复性较大，可考虑在成绩字段上建立聚集索引对索引列和索引类型的选择没有绝对的界限，在实际应用中，要综合各要素点具体分析，以达到系统的性能综合最优。</code></pre><h3 id="3查询优化"><a href="#3查询优化" class="headerlink" title="3查询优化"></a>3查询优化</h3><p>在数据库的所有操作中，查询操作占有很大的<br>比例，查询速度的快慢直接影响到应用系统的生命<br>力，因此设计较为优化的查询语句对提高数据库的<br>整体性能有着重要的作用。实践证明，在许多情况下<br>均可找到语义等价的查询，而选择不同的查询语句<br>对查询效率的影响大不相同，尤其是在一些大规模<br>的关系数据库应用系统中更加明显。本文以应用实<br>例为基础，结合数据库理论，探讨查询优化技术在现<br>实系统中的运用。<br>设在某学生管理系统中有如下3个关系：</p><pre><code>(1)学生登记表S(学号SN0，姓名SNAME，年龄AGE，性别SEX，院系SDEPT)；(2)学习登记表SC(学号SNO ，课程号CN0，成绩GRADE)；(3)课程登记表C(课程号CN()，课程名</code></pre><p>CNAME，开课院系CDEPT，教师TNAME)。</p><h4 id="3．1在条件子旬中使用索引"><a href="#3．1在条件子旬中使用索引" class="headerlink" title="3．1在条件子旬中使用索引"></a>3．1在条件子旬中使用索引</h4><p>正确使用索引可以大大提高查询效率，在条件<br>子句中应尽量考虑以下有用索引的使用。</p><h5 id="1-使用单列索引。"><a href="#1-使用单列索引。" class="headerlink" title="(1)使用单列索引。"></a>(1)使用单列索引。</h5><p>例如，在学生登记表中，如果创建学号为单列索<br>引，那么下列查询语句的 WHERE 子句中应使用学<br>号这个索引，使之成为有用索引。如果使用了其他字<br>段，创建学号这个索引则为无用索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  SNO ，SNAME，SEX</span><br><span class="line">FR0M S</span><br><span class="line"> WHERE  SNO =’S1’</span><br></pre></td></tr></table></figure><h5 id="2-使用复合索引时，必须保证在条件子句中首先使用复合索引的第一列。"><a href="#2-使用复合索引时，必须保证在条件子句中首先使用复合索引的第一列。" class="headerlink" title="(2)使用复合索引时，必须保证在条件子句中首先使用复合索引的第一列。"></a>(2)使用复合索引时，必须保证在条件子句中首先使用复合索引的第一列。</h5><p>例如，在学习登记表中，如果创建学号和课程号<br>为复合索引，下列查询中复合索引的使用是有用的，<br>因为SN0是复合索引的第一列字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN0．GRADE</span><br><span class="line">FR0MSC</span><br><span class="line"> WHERE SNO =’S3’AND CNO =’C1’</span><br></pre></td></tr></table></figure><p>但是，下列复合索引的使用是没用的，系统仍然<br>采用顺序扫描方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  SN0，GRADE</span><br><span class="line">FR0M SC</span><br><span class="line"> WHERE  CNO =’C1’ AND SNO =’S3’</span><br></pre></td></tr></table></figure><h4 id="3．2采用嵌套查询"><a href="#3．2采用嵌套查询" class="headerlink" title="3．2采用嵌套查询"></a>3．2采用嵌套查询</h4><p>嵌套查询(子查询)是指在 WHERE 或<br>HAVING条件子句中又包含了另一个SELECT 查<br>询语句的查询。执行时先执行最内层的子查询，再由<br>内到外逐层进行，通过子查询的层层选择、投影，中<br>间结果元组及属性的数目都得到有效的缩减，使条<br>件判断时的扫描工作仅限于较小范围内，提高检索<br>效率。嵌套查询比联接查询效率要高。</p><p>例如，查询选修课程名为“数据库原理”的学生<br>学号和姓名。</p><p>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO ，SNAME FROM  C，SC，S</span><br><span class="line"> WHERE  CNAME=’数据库原理’AND C．</span><br><span class="line">CNO =SC．CNO </span><br><span class="line">AND SC．SNO =S．SNO</span><br></pre></td></tr></table></figure><p>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO ，SNAME FROM  S</span><br><span class="line"> WHERE  SN0 IN</span><br><span class="line">(SELECT SNO  FROM  SC  WHERE  CNO  IN</span><br><span class="line">(SELECT CNO  FROM  C  WHERE  CNAME=</span><br><span class="line">’数据库原理’))</span><br></pre></td></tr></table></figure><p>由于查询1采用联接查询，只有学号和姓名为<br>输出属性，但几乎所有届性都要参加选择、联接运<br>算，多余的属性占用了较大的内存空间；另外3个表<br>的笛卡尔积将产生大量的中间结果，使选择操作时<br>需处理大量数目的元组。</p><p>查询2采用子查询，投影和选择运算同时进行，<br>对C表进行扫描选择后，仅剩下少量满足条件的元<br>组，接着投影操作将其它属性统统剔除，只保留“课<br>程号”一个属性，这样产生一个元组数目和属性数目<br>都较小的中间结果，大大减少了其外层对SC表查<br>询时的比较次数；同理，对SC表的扫描结果又减少<br>了其外层对S表查询时的比较次数。从而提高了检<br>索效率。</p><p>这里需要指出的是，使用嵌套查询时，要避免采<br>用相关子查询。即子查询中查询条件依赖于外层查<br>询中的某个值，当主查询中的列值改变之后，子查询<br>必须重新查询一次，查询嵌套层次越多，效率越低，<br>比联接查询的效率更低。</p><h4 id="3．3尽早执行选择操作"><a href="#3．3尽早执行选择操作" class="headerlink" title="3．3尽早执行选择操作"></a>3．3尽早执行选择操作</h4><p>尽可能早地执行选择操作，以减少运算量。例<br>如，检索选修课程名为“高数”的学生的学号和姓名。<br>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.SNO ，S.SNAME</span><br><span class="line">FROM S，C，SC</span><br><span class="line"> WHERE C.CNO =SC.CNO AND SC．SNO =S．SNO AND CNAME=’高数’</span><br></pre></td></tr></table></figure><p>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.SNO ，S.SNAME</span><br><span class="line">FROM S，C，SC</span><br><span class="line"> WHERE CNAME=’高数’AND C.CNO </span><br><span class="line">=SC.CNO AND SC.SNO =S.SNO</span><br></pre></td></tr></table></figure><p>执行这两条查询语句时，在对表S、C和SC笛<br>卡尔积的中间结果筛选时，查询2执行的比较次数<br>较查询1要少，因为其首先利用是否选修高数这一<br>条件排除了大量的元组，只有满足此条件的元组才<br>需要进行课程号和学号的相等判断。</p><h4 id="3．4尽早消掉不满足条件的记录"><a href="#3．4尽早消掉不满足条件的记录" class="headerlink" title="3．4尽早消掉不满足条件的记录"></a>3．4尽早消掉不满足条件的记录</h4><p>having子句中的限制条件应尽量多地放人<br> WHERE 子句中，以尽早把不满足条件的记录消掉。</p><p>例如，分别统计选修C1和C2课程的学生人<br>数，当选修超过50人时，显示学生的学号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO FROM SC</span><br><span class="line">GROUP BY CN0</span><br><span class="line">HAVING(CNO =’C1’ OR CNO =’C2’) AND</span><br><span class="line">C0UNT(*)&gt;50</span><br></pre></td></tr></table></figure><p>应改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO FROM SC</span><br><span class="line"> WHERE CNO =’C1’ OR CNO =’C2’</span><br><span class="line">GROUPBY CNO </span><br><span class="line">HAVING COUNT(*)&gt;50</span><br></pre></td></tr></table></figure><p>3．5分组计数<br>例如，找出选修全部课程的学生姓名。<br>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNAME FROM S</span><br><span class="line"> WHERE NOT EXISTS</span><br><span class="line">(SELECT*FROM C WHERE NOT</span><br><span class="line">EXESTS</span><br><span class="line">(SELECT * FROM SC WHERE S.SNO =</span><br><span class="line">SC．SNO ANDC．CNO =SC.CNO ))</span><br></pre></td></tr></table></figure><p>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNAME FROM S WHERE SNO </span><br><span class="line">IN</span><br><span class="line">(SELECT DISTINCTS NO FROM SC</span><br><span class="line">GROUPBY SNO </span><br><span class="line">HAVING COUNT(CNO )=(SELECT</span><br><span class="line">COUNT(CNO )FROM C))</span><br></pre></td></tr></table></figure><p>由于全部课程构成1个集合，如果成绩登记表<br>按学号分组，只要比较每个学生选修的课程集合是<br>否与全部课程构成的集合相等，即可判断某学生是<br>否选修了全部课程。可以证明，对于有引用关系的集<br>合而言，集合中元素数目相等则集合相同，因此查询<br>条件中若某学生选的课程数目等于课程表的记录总<br>数时，表示该同学选修了全部课程。查询2较查询1<br>效率较高。</p><h4 id="3．6避免困难的正规表达式"><a href="#3．6避免困难的正规表达式" class="headerlink" title="3．6避免困难的正规表达式"></a>3．6避免困难的正规表达式</h4><p>正规表达式即为使用IIKE等关键字支持通配<br>符匹配，但这种匹配特别耗费时间。例如，从学生登<br>记表中选出以‘2000’为前缀的学号的学生。<br>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *FROM S  WHERE SNO LIKE</span><br><span class="line">’2000</span><br></pre></td></tr></table></figure><p>一<br>’<br>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *FROM S WHERE (SNO &gt;</span><br><span class="line">’2000000’)AND(SNO &lt;’2001000’)</span><br></pre></td></tr></table></figure><p>对于这两种查询，既使在学号字段上建立索引，<br>查询1仍是采用顺序扫描的方式，查询2则是利用<br>学号索引进行定位，显然大大提高了速度。</p><h3 id="4表的优化"><a href="#4表的优化" class="headerlink" title="4表的优化"></a>4表的优化</h3><p>数据库逻辑设计时，依据范化理论把数据划分<br>成多个相关的表。但随着规范化程度的增加，查询时<br>要求联接的表的数目和复杂性也随之增加，系统复<br>杂的联接运算将影响整体性能。另外对于某些查询<br>要求，使用单个查询语句获得查询结果是较困难的<br>工作，特别是对于大型数据库系统，不容易检查查询<br>结果，要确定查询的正确与否非常困难。针对这些情<br>况，通过引人临时表来简化查询。</p><p>例如，查询某个学生某门课程的成绩。这个查询<br>的使用频率较高，则对其建立一个临时表TEMPSC<br>(学号(SNO )、姓名(SNAME)、课程名(CNAME)、<br>教师(TNAME)、成绩(GRADE))，并将对表S、C及<br>SC的查询结果写人表TEMPSC中。后续查询时直<br>接对表TEMPSC操作即可，简化了查询工作。</p><p>又如查询具有最多女生的系的名称。使用单条<br>查询语句获得查询结果较为困难，则可建立临时表<br>TEMPW(院系(SDEPT)、人数(NUMBER))，先将<br>各院系女生人数的统计结果写人此表，再在表<br>TEMPW中查出人数最多的院系名称。通过分解操<br>作过程，使解决办法得以简化。</p><p>使用临时表时要注意对它的更新操作，以保持<br>与原始表之间数据的一致性。使用完毕后，应对其删<br>除，释放其所占用的空间。</p><h3 id="5结束语"><a href="#5结束语" class="headerlink" title="5结束语"></a>5结束语</h3><p>数据库的优化设计工作对提高系统执行效率起<br>着重要的作用，本文从关系模式的规范化，索引和临<br>时表的建立以及查询优化这几个重要技术的几个方<br>面对数据库优化方案进行探讨。实际运用时，首先在<br>逻辑设计阶段根据范式优化及表优化中的要求设计<br>数据库逻辑结构，对两者的利弊进行权衡，选出折衷<br>的方案，既避免不一致性和数据异常现象，又不影响<br>整体的性能；接着在数据库物理设计阶段根据索引<br>优化中的要求在有关属性或属性的组合上建立索<br>引，以优化数据库物理结构；最后，在数据库查询阶<br>段，采用本文给出，6种优化策略，可大大提高查询<br>效率。总之，数据库设计时，要根据具体情况将上述<br>几个方面的优化策略有机地结合起来，尽可能使系<br>统效率达到最优。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库优化设计方法初探&quot;&gt;&lt;a href=&quot;#数据库优化设计方法初探&quot; class=&quot;headerlink&quot; title=&quot;数据库优化设计方法初探&quot;&gt;&lt;/a&gt;数据库优化设计方法初探&lt;/h2&gt;&lt;p&gt;随着数据库技术的发展，人们越来越依赖于计&lt;br&gt;算机化的业务数据。但
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>golang一些有用的小技巧</title>
    <link href="http://yoursite.com/2019/11/02/golang%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/11/02/golang小技巧/</id>
    <published>2019-11-02T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化一个定时器"><a href="#初始化一个定时器" class="headerlink" title="初始化一个定时器"></a>初始化一个定时器</h2><p><a href="https://www.kancloud.cn/digest/batu-go/153534" target="_blank" rel="noopener">来源链接</a></p><p><code>ticker := time.NewTimer(2 * time.Second)</code><br>这样就初始化了一个2秒的定时器</p><p>再看一个实际的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    //初始化定时器</span><br><span class="line">    t := time.NewTimer(2 * time.Second)</span><br><span class="line">    //当前时间</span><br><span class="line">    now := time.Now()</span><br><span class="line">    fmt.Printf(&quot;Now time : %v.\n&quot;, now)</span><br><span class="line"></span><br><span class="line">    expire := &lt;- t.C</span><br><span class="line">    fmt.Printf(&quot;Expiration time: %v.\n&quot;, expire)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以time包的NewTimer可以应用在一些调度任务中</p><p>再看一下复杂点的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    //初始化通道</span><br><span class="line">    ch11 := make(chan int, 1000)</span><br><span class="line">    sign := make(chan byte, 1)</span><br><span class="line"></span><br><span class="line">    //给ch11通道写入数据</span><br><span class="line">    for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">        ch11 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单独起一个Goroutine执行select</span><br><span class="line">    go func()&#123;</span><br><span class="line">        var e int</span><br><span class="line">        ok := true</span><br><span class="line">        //首先声明一个*time.Timer类型的值，然后在相关case之后声明的匿名函数中尽可能的复用它</span><br><span class="line">        var timer *time.Timer</span><br><span class="line"></span><br><span class="line">        for&#123;</span><br><span class="line">            select &#123;</span><br><span class="line">                case e = &lt;- ch11:</span><br><span class="line">                    fmt.Printf(&quot;ch11 -&gt; %d\n&quot;,e)</span><br><span class="line">                case &lt;- func() &lt;-chan time.Time &#123;</span><br><span class="line">                    if timer == nil&#123;</span><br><span class="line">                        //初始化到期时间据此间隔1ms的定时器</span><br><span class="line">                        timer = time.NewTimer(time.Millisecond)</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        //复用，通过Reset方法重置定时器</span><br><span class="line">                        timer.Reset(time.Millisecond)</span><br><span class="line">                    &#125;</span><br><span class="line">                    //得知定时器到期事件来临时，返回结果</span><br><span class="line">                    return timer.C</span><br><span class="line">                &#125;():</span><br><span class="line">                    fmt.Println(&quot;Timeout.&quot;)</span><br><span class="line">                    ok = false</span><br><span class="line">                    break</span><br><span class="line">            &#125;</span><br><span class="line">            //终止for循环</span><br><span class="line">            if !ok &#123;</span><br><span class="line">                sign &lt;- 0</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    //惯用手法，读取sign通道数据，为了等待select的Goroutine执行。</span><br><span class="line">    &lt;- sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="time-After函数"><a href="#time-After函数" class="headerlink" title="time.After函数"></a>time.After函数</h2><p>time.After函数</p><ul><li><p>表示多少时间之后，但是在取出channel内容之前不阻塞，后续程序可以继续执行</p></li><li><p>鉴于After特性，其通常用来处理程序超时问题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    ch1 := make(chan int, 1)</span><br><span class="line">    ch2 := make(chan int, 1)</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">        case e1 := &lt;-ch1:</span><br><span class="line">        //如果ch1通道成功读取数据，则执行该case处理语句</span><br><span class="line">            fmt.Printf(&quot;1th case is selected. e1=%v&quot;,e1)</span><br><span class="line">        case e2 := &lt;-ch2:</span><br><span class="line">        //如果ch2通道成功读取数据，则执行该case处理语句</span><br><span class="line">            fmt.Printf(&quot;2th case is selected. e2=%v&quot;,e2)</span><br><span class="line">        case &lt;- time.After(2 * time.Second):</span><br><span class="line">            fmt.Println(&quot;Timed out&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="golang打印结构体"><a href="#golang打印结构体" class="headerlink" title="golang打印结构体"></a>golang打印结构体</h3><p>如果使用fmt.println（v）<br>打印的结果往往令人迷惑，要想看到结构体内部的数据可以使用<br><code>fmt.printf(&quot;+v&quot;,v)</code></p><p><strong>如果需要打印的内容是一个<code>[]</code>byte</strong></p><p>那么使用 fmt.printf(“%s”,v)<br>就可以把这个切片字节的字符串打印出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初始化一个定时器&quot;&gt;&lt;a href=&quot;#初始化一个定时器&quot; class=&quot;headerlink&quot; title=&quot;初始化一个定时器&quot;&gt;&lt;/a&gt;初始化一个定时器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/digest/batu-g
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="golang" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/golang/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>docker file中使用多个FROM</title>
    <link href="http://yoursite.com/2019/10/20/docker-multi-from/"/>
    <id>http://yoursite.com/2019/10/20/docker-multi-from/</id>
    <published>2019-10-20T09:17:18.000Z</published>
    <updated>2019-11-03T13:12:48.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="能否使用多个FROM"><a href="#能否使用多个FROM" class="headerlink" title="能否使用多个FROM?"></a>能否使用多个FROM?</h2><p>在使用docker过程中，dockerhub上的docker镜像往往已经能够满足需求，<br>然鹅，需求是无止境的。有时候我们需要特殊定制一些镜像。我们需要A镜像中的一些文件,以及B镜像中的另外一些文件，以及….</p><a id="more"></a><h2 id="多个-FROM-指令的意义"><a href="#多个-FROM-指令的意义" class="headerlink" title="多个 FROM 指令的意义"></a>多个 FROM 指令的意义</h2><p>多个 FROM 指令并不是为了生成多根的层关系，最后生成的镜像，仍以最后一条 FROM 为准，之前的 FROM 会被抛弃，那么之前的FROM 又有什么意义呢？</p><p>每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。</p><h2 id="构造器模式是什么？"><a href="#构造器模式是什么？" class="headerlink" title="构造器模式是什么？"></a>构造器模式是什么？</h2><p>对于像Golang这样的静态编译语言，人们倾向于从Golang“ SDK”映像中获取其Dockerfile，添加源代码，进行构建，然后将其推送到Docker Hub。但是生成的镜像的大小至少为670M。</p><p>一种非官方的构造器模式(<strong>builder pattern</strong>) 的解决方法是使用两个Docker映像-一个用于执行构建，另一个用于发送第一个构建的结果，而不会破坏第一个映像中的构建链和工具。<br>Golang并不是唯一可以通过使用一个基础映像来构建资产并使用第二个映像来运行资产而受益的语言。<br>在Windows容器中的工作也使用此模式来生成较小的图像。</p><p>builder pattern的示例：</p><ol><li>从Golang基本映像派生整个运行时/ SDK（Dockerfile.build）</li><li>添加源代码</li><li>产生一个静态链接的二进制文件</li><li>将静态二进制文件从镜像复制到主机（docker create，docker cp）</li><li>从<code>SCRATCH</code>或其他轻量级映像分离，例如<code>alpine</code>（Dockerfile）</li><li>重新添加二进制文件</li><li>将这个很小的映像推送到Docker Hub</li></ol><p>这意味着要有两个单独的Dockerfile和一个Shell脚本来编排以上所有7个步骤。</p><p>以一个golang的项目为例：</p><p>Dockerfile.build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>build.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo Building alexellis2/href-counter:build</span><br><span class="line"></span><br><span class="line">docker build --build-arg https_proxy=$https_proxy --build-arg http_proxy=$http_proxy \</span><br><span class="line">    -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract alexellis2/href-counter:build </span><br><span class="line">docker cp extract:/go/src/github.com/alexellis/href-counter/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building alexellis2/href-counter:latest</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><h2 id="什么是多阶段构建？"><a href="#什么是多阶段构建？" class="headerlink" title="什么是多阶段构建？"></a>什么是多阶段构建？</h2><p>多阶段构建具有构建器模式的优点，而无需维护三个单独的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>但是，对于开发者和维护者来说，这仍然很大，特别是使用树莓派的用户。<br>在Dockerfile中使用多个FROM-以最后一条FROM语句为最终基础映像为准<br>。要复制中间图像的伪像和输出，<br>请使用<code>COPY --from=镜像号码</code></p><p>改进后的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>有些程序要么没有apt源，要么apt源中的版本太老，<br>要么干脆只提供源码需要自己编译，使用这些程序时，<br>我们可以方便地使用已经存在的Docker镜像源作为我们的基础镜像。<br>但是我们的软件有时候可能需要依赖多个这种文件，<br>我们并不能同时将 nginx 和 etcd 的镜像同时作为我们的基础镜像<br>（不支持多根），这种情况下，使用 COPY –from 就非常方便实用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;能否使用多个FROM&quot;&gt;&lt;a href=&quot;#能否使用多个FROM&quot; class=&quot;headerlink&quot; title=&quot;能否使用多个FROM?&quot;&gt;&lt;/a&gt;能否使用多个FROM?&lt;/h2&gt;&lt;p&gt;在使用docker过程中，dockerhub上的docker镜像往往已经能够满足需求，&lt;br&gt;然鹅，需求是无止境的。有时候我们需要特殊定制一些镜像。我们需要A镜像中的一些文件,以及B镜像中的另外一些文件，以及….&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>moviepy 中文镜像</title>
    <link href="http://yoursite.com/2019/10/20/moviepy-docker/"/>
    <id>http://yoursite.com/2019/10/20/moviepy-docker/</id>
    <published>2019-10-20T09:17:18.000Z</published>
    <updated>2019-11-04T17:15:57.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先是系统的环境问题。"><a href="#首先是系统的环境问题。" class="headerlink" title="首先是系统的环境问题。"></a>首先是系统的环境问题。</h2><p>linux 安装 moviepy需要很多依赖，安装起来费神费力。配置起来也非常麻烦，最简单的办法是直接使用他人构建好的镜像文件。</p><a id="more"></a><h2 id="再就是字体显示问题。"><a href="#再就是字体显示问题。" class="headerlink" title="再就是字体显示问题。"></a>再就是字体显示问题。</h2><p>镜像中的imagmagick不支持中文的字体。生成的视频中文乱码，搜索了好!</p><p>长时间，决定自己手动构建一个镜像。参考的文章链接：</p><p><a href="https://www.cnblogs.com/dunkbird/p/5623209.html" target="_blank" rel="noopener">linux追加中文字库，解决imagemagick 中文乱码的问题</a></p><p><a href="https://blog.csdn.net/soulmate_P/article/details/8785642" target="_blank" rel="noopener">Linux(Ubuntu，Cent OS)环境安装mkfontscale mkfontdir命令以及中文字库</a></p><p>步骤简单分为几步：</p><ul><li>拷贝本地Windows下的font（选择你想要的）到镜像中。</li><li>镜像安装构建字体的依赖</li><li>构建字体文件夹</li><li>build 镜像</li></ul><p>放一下Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM dkarchmervue/moviepy:latest</span><br><span class="line"># 我在同级目录下创建了一个windows_fonts文件夹，里面放着从window下拷贝过来的文件。考本到镜像的字体文件夹下。</span><br><span class="line">COPY ./wondow_fonts/ /usr/share/fonts/windows/</span><br><span class="line"># 更改ubuntu镜像源，dkarchmervue/moviepy是基于ubuntu14.04，找一个镜像源，在本地创建一个sources.list的文件，拷贝到镜像中就可以。</span><br><span class="line">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">COPY sources.list /etc/apt/sources.list </span><br><span class="line">RUN apt-get update</span><br><span class="line"># 安装添加字体的依赖</span><br><span class="line">RUN apt-get install ttf-mscorefonts-installer -y &amp;&amp; apt-get install fontconfig -y\</span><br><span class="line">     &amp;&amp; apt-get install fontconfig \</span><br><span class="line">    &amp;&amp; cd /usr/share/fonts/windows/ &amp;&amp; chmod 777 * &amp;&amp; mkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache</span><br><span class="line">WORKDIR /work/</span><br></pre></td></tr></table></figure><p>这样就制作了一个基于<code>dkarchmervue/moviepy</code> 的带中文字体的镜像。<br>然后直接运行 <code>docker build -t moviepy_cnfonts .</code> 即可创建一个名为 moviepy_cnfonts的镜像。可以把这个镜像替代<code>dkarchmervue/moviepy:latest</code>这个镜像作为运行 python文件的基础镜像。</p><p>运行moviepy官方的结尾特效 end_effect</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1200357-20190919202017204-216254823.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;首先是系统的环境问题。&quot;&gt;&lt;a href=&quot;#首先是系统的环境问题。&quot; class=&quot;headerlink&quot; title=&quot;首先是系统的环境问题。&quot;&gt;&lt;/a&gt;首先是系统的环境问题。&lt;/h2&gt;&lt;p&gt;linux 安装 moviepy需要很多依赖，安装起来费神费力。配置起来也非常麻烦，最简单的办法是直接使用他人构建好的镜像文件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="moviepy" scheme="http://yoursite.com/tags/moviepy/"/>
    
  </entry>
  
  <entry>
    <title>python-cache</title>
    <link href="http://yoursite.com/2019/10/03/python-cache/"/>
    <id>http://yoursite.com/2019/10/03/python-cache/</id>
    <published>2019-10-03T04:42:40.000Z</published>
    <updated>2019-11-04T17:15:57.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msgpack介绍"><a href="#msgpack介绍" class="headerlink" title="msgpack介绍"></a>msgpack介绍</h2><p>在阅读sanic相关项目的时候 <a href=""https://github.com/howie6879/Sanic-For-Pythoneer/blob/master/docs/part1/6.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7.md"">Sanic-For-Pythoneer</a> 阅读代码过程中发现几个比较好用的python库，</p><h3 id="1-cached"><a href="#1-cached" class="headerlink" title="1. cached"></a>1. cached</h3><p>缓存其实应用场景还是比较多的。比如我现在应用的就是对 从database中获取到的数据做缓存，设置ttl(time to live)以减小数据库压力。</p><a id="more"></a><p>cached的简单应用 （python = 3.7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import aiocache</span><br><span class="line">from aiocache.serializers import NullSerializer, StringSerializer, \</span><br><span class="line">    PickleSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@aiocache.cached(ttl=10, serializer=PickleSerializer())</span><br><span class="line">async def get_res():</span><br><span class="line">    print(&quot;get_res(): int(11)&quot;)</span><br><span class="line">    return 11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import asyncio</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    data = asyncio.run(get_res())</span><br><span class="line">    print(type(data), data)</span><br><span class="line">    data = asyncio.run(get_res())</span><br><span class="line">    print(type(data), data)</span><br></pre></td></tr></table></figure><p>aiocache实现并不复杂。介绍一下 SimpleMemoryCache。大致的思路就是 把数据保存到字典中，key默认为 model_name+ func_name + args + kwargs 组合（可以指定key的值），到了ttl设定的时间就把map中的键值pop出去。<br>其他的也是类似的思路。</p><p>这里值得注意的是 <code>serializer</code>这个参数。如果是使用 <code>SimpleMemoryCache</code>作为缓存，默认是使用 <code>NullSerializer</code>作为序列化工具的，即set的任何内容都可以在get时原样获取，在本地内存中这一点问题没有。<br>如果需要对对象序列化 建议使用 <code>PickleSerializer</code><br><a href=""https://www.zhihu.com/question/38355589"">我是pickle</a></p><p>但是如果使用redis作为缓存，会发生一些预测不到的错误。解决办法是使用：<code>JsonSerializer</code>,内部使用的是 <code>ujson</code>作为序列化工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json module and ujson:</span><br><span class="line">        - ujson dumps supports bytes while json doesn&apos;t</span><br><span class="line">        - ujson and json outputs may differ sometimes</span><br></pre></td></tr></table></figure><p>还有一个 <code>MsgPackSerializer</code>,</p><p><code>Transform data to bytes using msgpack.dumps and msgpack.loads to retrieve it back.</code></p><p>还有一个序列化参数，用的比较少，<code>StringSerializer</code>,比如你缓存的是 1，在下次获取缓存结果的时候会给你返回 <code>&#39;1&#39;</code>。</p><h3 id="2-msgpack"><a href="#2-msgpack" class="headerlink" title="2. msgpack"></a>2. msgpack</h3><p>msgpack 是cached包安装时候的依赖。进入源码，发现其对外提供的API非常简单，用法与 ujson,json 等序列/反序列工具基本一直。</p><p>其源码中对外暴露方法做了常规化处理，这样我们用起来很快适应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># alias for compatibility to simplejson/marshal/pickle.</span><br><span class="line">load = unpack</span><br><span class="line">loads = unpackb</span><br><span class="line"></span><br><span class="line">dump = pack</span><br><span class="line">dumps = packb</span><br></pre></td></tr></table></figure><p>msgpack的优势是：msgpack用起来像json，但是却比json快，并且序列化以后的数据长度更小，言外之意，使用msgpack不仅序列化和反序列化的速度快，数据传输量也比json格式小，msgpack同样支持多种语言。</p><p>我们平时主要会用到 <code>loads</code> 等同于 <code>unpackb</code> , <code>dumps</code> 等同于 <code>packb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import msgpack</span><br><span class="line">&gt;&gt;&gt;animal = &#123;&quot;color&quot;:&quot;pink&quot;,&quot;name&quot;:&quot;duck&quot;&#125;</span><br><span class="line">&gt;&gt;&gt;msgpack.dumps(animal) // 比 json.dumps(x)的长度更小</span><br><span class="line">b&apos;\x82\xa5color\xa4pink\xa4name\xa4duck&apos;</span><br><span class="line">&gt;&gt;&gt;msgpack.loads(msgpack.dumps(animal))</span><br><span class="line">&#123;b&apos;color&apos;: b&apos;pink&apos;, b&apos;name&apos;: b&apos;duck&apos;&#125;</span><br><span class="line">&gt;&gt;&gt;msgpack.loads(msgpack.dumps(animal),encoding=&quot;utf-8&quot;) // 转会初始状态的字符串，需要加上 encoding这个参数，内部会调用decode()方法</span><br><span class="line">&#123;&apos;color&apos;: &apos;pink&apos;, &apos;name&apos;: &apos;duck&apos;&#125;</span><br></pre></td></tr></table></figure><p>另外 load 和 dump的用法和json.load &amp; json.dump用法相同。<br>该包源码非常简单，有兴趣的可以去看看源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;msgpack介绍&quot;&gt;&lt;a href=&quot;#msgpack介绍&quot; class=&quot;headerlink&quot; title=&quot;msgpack介绍&quot;&gt;&lt;/a&gt;msgpack介绍&lt;/h2&gt;&lt;p&gt;在阅读sanic相关项目的时候 &lt;a href=&quot;&quot;https://github.com/howie6879/Sanic-For-Pythoneer/blob/master/docs/part1/6.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7.md&quot;&quot;&gt;Sanic-For-Pythoneer&lt;/a&gt; 阅读代码过程中发现几个比较好用的python库，&lt;/p&gt;
&lt;h3 id=&quot;1-cached&quot;&gt;&lt;a href=&quot;#1-cached&quot; class=&quot;headerlink&quot; title=&quot;1. cached&quot;&gt;&lt;/a&gt;1. cached&lt;/h3&gt;&lt;p&gt;缓存其实应用场景还是比较多的。比如我现在应用的就是对 从database中获取到的数据做缓存，设置ttl(time to live)以减小数据库压力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>flask.run()不是你的服务器！</title>
    <link href="http://yoursite.com/2019/09/23/flask-is-not-production-server/"/>
    <id>http://yoursite.com/2019/09/23/flask-is-not-production-server/</id>
    <published>2019-09-23T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不要再用flask-run-部署项目了！"><a href="#不要再用flask-run-部署项目了！" class="headerlink" title="不要再用flask.run()部署项目了！"></a>不要再用flask.run()部署项目了！</h3><p>在维护公司老项目,服务器查看运行着一个flask项目。用简单的单进程跑在机器上。<br>查看详细的信息，发现是直接用这种方式运行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def route1():</span><br><span class="line">   pass</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(....)</span><br></pre></td></tr></table></figure><a id="more"></a><dl><dt>这种方式真的很不好，稍微看一下docs就能看到flask已经给了很明显的警高信息</dt><dd><code>WARNING: This is a development server. Do not use it in a production deployment.</code></dd></dl><h3 id="下面就来讲一讲为何不好-："><a href="#下面就来讲一讲为何不好-：" class="headerlink" title="下面就来讲一讲为何不好 ："></a><strong>下面就来讲一讲为何不好</strong> ：</h3><p>你已经构建了Flask网络应用，并正在部署自己选择的VPS上。这是你的第一个小型应用程序，你希望将app.run上的debug设置为False就足够了？也许也启用线程？</p><p>你真的不应该依赖于此。官方文档也不同意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">While lightweight and easy to use, Flask’s built-in server is </span><br><span class="line">not suitable for production as it doesn’t scale well </span><br><span class="line">and by default serves only one request at a time.</span><br></pre></td></tr></table></figure><p>现在怎么办？好吧，不要混为一谈。一切都很好，你只需要了解Flask部署Web服务器的用途，缺少的什么以及拿什么东西顶上就好了。</p><h4 id="Flask的内置Web服务器"><a href="#Flask的内置Web服务器" class="headerlink" title="Flask的内置Web服务器"></a>Flask的内置Web服务器</h4><p>Flask提供的内置 Web服务器是为了方便开发。</p><p>有了它，你就可以在本地计算机上访问你的应用程序，而无需开启其他服务并让它们协调工作。但是，它只能一次由一个人使用，<br>它就是以这种方式构建的–<strong>就是为了方便你开发</strong>。它也可以提供静态文件，但是与为快速处理文件而设计的工具(如nginx)相比，<br>这样做的速度非常慢。当只有一个人访问它时，这无关紧要，只要达到开发调试的目的就可以了。</p><p>在生产环境中运行Web应用程序时，我们希望它能够处理多个用户的过个请求，而那些使用我们服务的人不必为加载页面和静态文件焦急等待。</p><h4 id="生产栈结构"><a href="#生产栈结构" class="headerlink" title="生产栈结构"></a>生产栈结构</h4><p>生产环境的设置通常由多个组件组成，每个组件的设计和构建都非常擅长于同一件事–快速，可靠，专注。</p><p>就像内置Web服务器一样，与整个设备的通信都是通过HTTP进行的。一个请求进入并到达第一个组件-专用的Web服务器。<br>它非常适合从磁盘读取静态文件（例如，你的css，js文件）并处理多个请求。当请求不是静态文件时，<br>所有请求都将传递到堆栈中。</p><p>应用程序服务器获取这些的请求，并将这些请求中的信息转换为框架可以使用的Python对象-WSGI。</p><p>Flask应用实际上并未像我们想象的作为服务器等待请求并对它们做出反应。<br>而是可以被认为是被应用服务器作为方法调用，提供请求对象。</p><p>然后，应用程序服务器将运行应用程序的输出打包到HTTP响应中，并传递回Web服务器，再传递回给用户。</p><p>意思是<br>如果要在生产环境中运行Flask，请确保使用可用于生产环境的Web服务器，例如Nginx，并让你的应用程序由WSGI应用程序服务器（例如Gunicorn）处理。</p><p>完毕！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不要再用flask-run-部署项目了！&quot;&gt;&lt;a href=&quot;#不要再用flask-run-部署项目了！&quot; class=&quot;headerlink&quot; title=&quot;不要再用flask.run()部署项目了！&quot;&gt;&lt;/a&gt;不要再用flask.run()部署项目了！&lt;/h3&gt;&lt;p&gt;在维护公司老项目,服务器查看运行着一个flask项目。用简单的单进程跑在机器上。&lt;br&gt;查看详细的信息，发现是直接用这种方式运行的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def route1():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run(....)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>flask应用上下文和请求上下文</title>
    <link href="http://yoursite.com/2019/09/23/flask%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87&amp;%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://yoursite.com/2019/09/23/flask应用上下文&amp;请求上下文/</id>
    <published>2019-09-23T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask应用上下文和请求上下文"><a href="#flask应用上下文和请求上下文" class="headerlink" title="flask应用上下文和请求上下文"></a>flask应用上下文和请求上下文</h2><p>虽然现在已经是python3的时代，一些开发库已经不支持python2并且asyncio也越来越多的被应用。<br>但是个人感觉如果要解决高并发问题，使用asyncio并不是很好的实践。</p><a id="more"></a><p>因为协程之间并不是简单的调用切换，还涉及到一些协程间通信。<br>使用python还是以‘顺序’编程为主，如果公司对高并发真的是有急迫的需求，更好的选择应该是<code>golang</code></p><p>与<code>flask</code>对应的异步web框架是<code>sanic</code>。两者的编程风格很相似，包括核心app的构建方法，路由等。<br><code>sanic</code>是基于asyncio的事件回调机制来完成的，与tornado（老版的tornado是基于yield实现的类似于协程的切换）相比，性能及可读性更高一些。</p><p>我个人实际开发中对并发并没有很高的要求，所以应用最多的还是flask，原因很简单-需求驱动。</p><p>简单整理了flask的应用上下文和请求上下文的处理过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flask.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flask应用上下文和请求上下文&quot;&gt;&lt;a href=&quot;#flask应用上下文和请求上下文&quot; class=&quot;headerlink&quot; title=&quot;flask应用上下文和请求上下文&quot;&gt;&lt;/a&gt;flask应用上下文和请求上下文&lt;/h2&gt;&lt;p&gt;虽然现在已经是python3的时代，一些开发库已经不支持python2并且asyncio也越来越多的被应用。&lt;br&gt;但是个人感觉如果要解决高并发问题，使用asyncio并不是很好的实践。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch－基础介绍及索引原理分析</title>
    <link href="http://yoursite.com/2019/09/13/elaskticsearch/"/>
    <id>http://yoursite.com/2019/09/13/elaskticsearch/</id>
    <published>2019-09-13T13:47:23.000Z</published>
    <updated>2019-11-03T08:29:42.514Z</updated>
    
    <content type="html"><![CDATA[<p>#Elasticsearch－基础介绍及索引原理分析</p><p>最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。</p><a id="more"></a><p>##介绍<br>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p><ul><li><p>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</p></li><li><p>实时分析的分布式搜索引擎。</p></li><li><p>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</p></li></ul><p>##基本概念<br>先说Elasticsearch的文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据：</p><p>{<br>“name” : “John”,<br>“sex” : “Male”,<br>“age” : 25,<br>“birthDate”: “1990/05/01”,<br>“about” : “I love to go rock climbing”,<br>“interests”: [ “sports”, “music” ]<br>}<br>用Mysql这样的数据库存储就会容易想到建立一张User表，有balabala的字段等，在Elasticsearch里这就是一个文档，当然这个文档会属于一个User的类型，各种各样的类型存在于一个索引当中。这里有一份简易的将Elasticsearch和关系型数据术语对照表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)</span><br><span class="line"></span><br><span class="line">Elasticsearch ⇒ 索引(Index) ⇒ 类型(type) ⇒ 文档(Docments) ⇒ 字段(Fields)</span><br></pre></td></tr></table></figure><p>一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式，比如我们打算插入一条记录，可以简单发送一个HTTP的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot; : &quot;John&quot;,</span><br><span class="line">&quot;sex&quot; : &quot;Male&quot;,</span><br><span class="line">&quot;age&quot; : 25,</span><br><span class="line">&quot;about&quot; : &quot;I love to go rock climbing&quot;,</span><br><span class="line">&quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新，查询也是类似这样的操作，具体操作手册可以参见Elasticsearch权威指南</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Elasticsearch最关键的就是提供强大的索引能力了，其实InfoQ的这篇时间序列数据库的秘密(2)——索引写的非常好，我这里也是围绕这篇结合自己的理解进一步梳理下，也希望可以帮助大家更好的理解这篇文章。<br>Elasticsearch索引的精髓：</p><blockquote><p>一切设计都是为了提高搜索的性能</p></blockquote><p>另一层意思：为了提高搜索的性能，难免会牺牲某些其他方面，比如插入/更新，否则其他数据库不用混了。前面看到往Elasticsearch里插入一条记录，其实就是直接PUT一个json的对象，这个对象有多个fields，比如上面例子中的name, sex, age, about, interests，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默1的为这些字段建立索引–倒排索引，因为Elasticsearch最核心功能是搜索。<br>###Elasticsearch是如何做到快速索引的<br>InfoQ那篇文章里说Elasticsearch使用的倒排索引比关系型数据库的B-Tree索引快，为什么呢？<br>###什么是B-Tree索引?<br>上大学读书时老师教过我们，二叉树查找效率是logN，同时插入新的节点不必移动全部节点，<br>所以用树型结构存储索引，能同时兼顾插入和查询的性能。因此在这个基础上，<br>再结合磁盘的读取特性(顺序读/随机读)，传统关系型数据库采用了B-Tree/B+Tree这样的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/b-tree.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，<br>一次寻道读取多个数据，同时也降低树的高度。<br>###什么是倒排索引?</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/inverted-index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>继续上面的例子，假设有这么几条数据(为了简单，去掉about, interests这两个field):</p><table><thead><tr><th>ID</th><th align="center">Name</th><th align="right">Age</th><th align="right">Sex</th></tr></thead><tbody><tr><td>1</td><td align="center">Kate</td><td align="right">24</td><td align="right">Female</td></tr><tr><td>2</td><td align="center">John</td><td align="right">24</td><td align="right">Male</td></tr><tr><td>3</td><td align="center">Bill</td><td align="right">29</td><td align="right">Male</td></tr></tbody></table><p>ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下:<br>Name:</p><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Kate</td><td align="center">1</td></tr><tr><td>John</td><td align="center">2</td></tr><tr><td>Bill</td><td align="center">3</td></tr><tr><td>Age:</td><td align="center"></td></tr></tbody></table><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>24</td><td align="center">[1,2]</td></tr><tr><td>29</td><td align="center">3</td></tr><tr><td>Sex:</td><td align="center"></td></tr></tbody></table><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Female</td><td align="center">1</td></tr><tr><td>Male</td><td align="center">[2,3]</td></tr></tbody></table><ul><li>Posting List</li></ul><p>Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而[1,2]就是Posting List。Posting list就是一个int的数组，存储了所有符合某个term的文档id。<br>看到这里，不要认为就结束了，精彩的部分才刚开始…<br>通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，爱回答问题的小明马上就举手回答：我知道，id是1，2的同学。但是，如果这里有上千万的记录呢？如果是想通过name来查找呢？</p><ul><li>Term Dictionary</li></ul><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。现在再看起来，似乎和传统数据库通过B-Tree的方式类似啊，为什么说比B-Tree的查询快呢？</p><ul><li>Term Index</li></ul><p>B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/term-index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。<br>这时候爱提问的小明又举手了:”那个FST是神马东东啊?”<br>一看就知道小明是一个上大学读书的时候跟我一样不认真听课的孩子，<br>数据结构老师一定讲过什么是FST。但没办法，我也忘了，这里再补下课：</p><blockquote><p>FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output.</p></blockquote><p>假设我们现在要将mop, moth, pop, star, stop and top(term index里的term前缀)映射到序号：0，1，2，3，4，5(term dictionary的block位置)。最简单的做法就是定义个Map&lt;string, integer=””&gt;，大家找到自己的位置对应入座就好了，但从内存占用少的角度想想，有没有更优的办法呢？答案就是：FST(<a href="http://www.cs.nyu.edu/~mohri/pub/fla.pdf" target="_blank" rel="noopener">理论依据在此，但我相信99%的人不会认真看完的</a>)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/fst.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>⭕️表示一种状态<br>–&gt;表示状态的变化过程，上面的字母/数字表示状态变化和权重<br>将单词分成单个字母通过⭕️和–&gt;表示出来，0权重不显示。如果⭕️后面出现分支，就标记权重，最后整条路径上的权重加起来就是这个单词对应的序号。<br><code>FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output.</code></p><p>FST以字节的方式存储所有的term，这种压缩方式可以有效的缩减存储空间，使得term index足以放进内存，但这种方式也会导致查找时需要更多的CPU资源。<br>后面的更精彩，看累了的同学可以喝杯咖啡……</p><h3 id="压缩技巧"><a href="#压缩技巧" class="headerlink" title="压缩技巧"></a>压缩技巧</h3><p>Elasticsearch里除了上面说到用FST压缩term index外，对posting list也有压缩技巧。<br>小明喝完咖啡又举手了:”posting list不是已经只存储文档id了吗？还需要压缩？”<br>嗯，我们再看回最开始的例子，如果Elasticsearch需要对同学的性别进行索引(这时传统关系型数据库已经哭晕在厕所……)，会怎样？如果有上千万个同学，而世界上只有男/女这样两个性别，每个posting list都会有至少百万个文档id。<br>Elasticsearch是如何有效的对这些文档id压缩的呢？</p><ul><li>Frame Of Reference</li></ul><blockquote><p>增量编码压缩，将大数变小数，按字节存储</p></blockquote><p>首先，Elasticsearch要求posting list是有序的(为了提高搜索的性能，再任性的要求也得满足)，这样做的一个好处是方便压缩，看下面这个图例：</p><p><img src="/images/frameOfReference.png" alt=""><br>如果数学不是体育老师教的话，还是比较容易看出来这种压缩技巧的。<br>原理就是通过增量，将原来的大数变成小数仅存储增量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字节)来存储。<br><strong>Roaring bitmaps</strong></p><p>说到Roaring bitmaps，就必须先从bitmap说起。Bitmap是一种数据结构，假设有某个posting list：<br><code>[1,3,4,7,10]</code><br>对应的bitmap就是：<br><code>[1,0,1,1,0,0,1,0,0,1]</code><br>非常直观，用0/1表示某个值是否存在，比如10这个值就对应第10位，对应的bit值是1，这样用一个字节就可以代表8个文档id，旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段(我们往往会有很多个索引字段)。于是有人想出了Roaring bitmaps这样更高效的数据结构。<br>Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性：<br>将posting list按照65535为界限分块，比如第一块所包含的文档id范围在0<del>65535之间，第二块的id范围是65536</del>131071，以此类推。再用&lt;商，余数&gt;的组合表示每一组id，这样每组里的id范围都在0~65535内了，剩下的就好办了，既然每组id不会变得无限大，那么我们就可以通过最有效的方式对这里的id存储。</p><p>细心的小明这时候又举手了:”为什么是以65535为界限?”<br>程序员的世界里除了1024外，65535也是一个经典值，因为它=2^16-1，正好是用2个字节能表示的最大数，一个short的存储单位，注意到上图里的最后一行“If a block has more than 4096 values, encode as a bit set, and otherwise as a simple array using 2 bytes per value”，如果是大块，用节省点用bitset存，小块就豪爽点，2个字节我也不计较了，用一个short[]存着方便。<br>那为什么用4096来区分大块还是小块呢？<br>个人理解：都说程序员的世界是二进制的，4096*2bytes ＝ 8192bytes &lt; 1KB, 磁盘一次寻道可以顺序把一个小块的内容都读出来，再大一位就超过1KB了，需要两次读。</p><ul><li><strong>联合索引</strong></li></ul><p>上面说了半天都是单field索引，如果多个field索引的联合查询，倒排索引如何满足快速查询的要求呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 利用跳表(Skip list)的数据结构快速做“与”运算，或者</span><br><span class="line"></span><br><span class="line">- 利用上面提到的bitset按位“与”</span><br></pre></td></tr></table></figure><p>先看看跳表的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/skiplist.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时依次从高level往低查找，比如55，先找到level2的31，再找到level1的47，最后找到55，一共3次查找，查找效率和2叉树的效率相当，但也是用了一定的空间冗余来换取的。<br>假设有下面三个posting list需要联合索引：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/combineIndex.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果。<br>如果使用bitset，就很直观了，直接按位与，得到的结果就是最后的交集。总结和思考<br>Elasticsearch的索引思路:</p><blockquote><p>将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。</p></blockquote><p>所以，对于使用Elasticsearch进行索引时需要注意:</p><ul><li><p>不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的</p></li><li><p>同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的</p></li><li><p>选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询</p></li></ul><p>关于最后一点，个人认为有多个因素:<br>其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高；<br>另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数，具体可以参考这篇如何选择一个高效的全局ID方案(评论也很精彩)</p><p>转自神一般的存在，<a href="http://blog.pengqiuyuan.com/ji-chu-jie-shao-ji-suo-yin-yuan-li-fen-xi/" target="_blank" rel="noopener">文章链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Elasticsearch－基础介绍及索引原理分析&lt;/p&gt;
&lt;p&gt;最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Nofollow链接 VS Follow链接：所有你需要了解的知识</title>
    <link href="http://yoursite.com/2019/08/13/what_is_nofollow/"/>
    <id>http://yoursite.com/2019/08/13/what_is_nofollow/</id>
    <published>2019-08-13T09:17:18.000Z</published>
    <updated>2019-12-02T09:59:00.595Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html > <!--[if !IE]><html class="no-js non-ie" lang="zh-Hans"> <![endif]--> <!--[if IE 7 ]><html class="no-js ie7" lang="zh-Hans"> <![endif]--> <!--[if IE 8 ]><html class="no-js ie8" lang="zh-Hans"> <![endif]--> <!--[if IE 9 ]><html class="no-js ie9" lang="zh-Hans"> <![endif]--> <!--[if gt IE 9]><!--><html class="no-js" lang="zh-Hans"> <!--<![endif]--><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="theme-color" content="#2254c4"/><link type="text/css" media="all" href="https://ahrefs.com/blog/zh/wp-content/cache/autoptimize/css/autoptimize_188c099d1ee431b0269010aedc586273.css" rel="stylesheet" /><title>什么是Nofollow链接？你需要知道的一切（没有废话！）</title><link rel="pingback" href="https://ahrefs.com/blog/zh/xmlrpc.php" /><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800|PT+Sans:400,400i,700,700i|PT+Serif:400,400i,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC|Noto+Serif+SC&display=swap" rel="stylesheet"> <script type="text/javascript">var _iub = _iub || []; _iub.csConfiguration = {"lang":"en","siteId":261877,"cookiePolicyId":794932};</script><script type="text/javascript" src="//cdn.iubenda.com/cookie_solution/safemode/iubenda_cs.js" charset="UTF-8" async></script> <script>var iCallback = function() {};var _iub = _iub || {};if ( typeof _iub.csConfiguration != 'undefined' ) {if ( 'callback' in _iub.csConfiguration ) {if ( 'onConsentGiven' in _iub.csConfiguration.callback )iCallback = _iub.csConfiguration.callback.onConsentGiven;_iub.csConfiguration.callback.onConsentGiven = function() {iCallback();/* separator */jQuery('noscript._no_script_iub').each(function (a, b) { var el = jQuery(b); el.after(el.html()); });}}}</script><meta name="description" content="Nofollowed vs. Dofollow链接。有什么不同？它们如何影响SEO？在完整指南中了解你需要的所有内容。"/><meta name="robots" content="max-snippet:-1, max-image-preview:large, max-video-preview:-1"/><link rel="canonical" href="https://ahrefs.com/blog/zh/nofollow-links/" /><meta property="og:locale" content="en_US" /><meta property="og:type" content="article" /><meta property="og:title" content="什么是Nofollow链接？你需要知道的一切（没有废话！）" /><meta property="og:description" content="Nofollowed vs. Dofollow链接。有什么不同？它们如何影响SEO？在完整指南中了解你需要的所有内容。" /><meta property="og:url" content="https://ahrefs.com/blog/zh/nofollow-links/" /><meta property="article:publisher" content="https://www.facebook.com/Ahrefs" /><meta property="article:section" content="SEO汇总" /><meta property="article:published_time" content="2019-07-30T04:14:28+00:00" /><meta property="article:modified_time" content="2019-11-21T02:03:01+00:00" /><meta property="og:updated_time" content="2019-11-21T02:03:01+00:00" /><meta property="og:image" content="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-facebook-1.jpg" /><meta property="og:image:secure_url" content="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-facebook-1.jpg" /><meta property="og:image:width" content="1200" /><meta property="og:image:height" content="628" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:description" content="Nofollowed vs. Dofollow链接。有什么不同？它们如何影响SEO？在完整指南中了解你需要的所有内容。" /><meta name="twitter:title" content="什么是Nofollow链接？你需要知道的一切（没有废话！）" /><meta name="twitter:site" content="@ahrefs" /><meta name="twitter:image" content="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-facebook-1.jpg" /><meta name="twitter:creator" content="@joshuachardwick" /> <script type='application/ld+json' class='yoast-schema-graph yoast-schema-graph--main'>{"@context":"https://schema.org","@graph":[{"@type":"WebSite","@id":"https://ahrefs.com/blog/zh/#website","url":"https://ahrefs.com/blog/zh/","name":"SEO Blog by Ahrefs","description":"Link Building Strategies &amp; SEO Tips","potentialAction":{"@type":"SearchAction","target":"https://ahrefs.com/blog/zh/?s={search_term_string}","query-input":"required name=search_term_string"}},{"@type":"ImageObject","@id":"https://ahrefs.com/blog/zh/nofollow-links/#primaryimage","url":"https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-facebook-1.jpg","width":1200,"height":628,"caption":"Nofollow links"},{"@type":"WebPage","@id":"https://ahrefs.com/blog/zh/nofollow-links/#webpage","url":"https://ahrefs.com/blog/zh/nofollow-links/","inLanguage":"zh-Hans","name":"\u4ec0\u4e48\u662fNofollow\u94fe\u63a5\uff1f\u4f60\u9700\u8981\u77e5\u9053\u7684\u4e00\u5207\uff08\u6ca1\u6709\u5e9f\u8bdd\uff01\uff09","isPartOf":{"@id":"https://ahrefs.com/blog/zh/#website"},"primaryImageOfPage":{"@id":"https://ahrefs.com/blog/zh/nofollow-links/#primaryimage"},"datePublished":"2019-07-30T04:14:28+00:00","dateModified":"2019-11-21T02:03:01+00:00","author":{"@id":"https://ahrefs.com/blog/zh/#/schema/person/03777ed319d5dcc465ad6764ba7b7d31"},"description":"Nofollowed vs. Dofollow\u94fe\u63a5\u3002\u6709\u4ec0\u4e48\u4e0d\u540c\uff1f\u5b83\u4eec\u5982\u4f55\u5f71\u54cdSEO\uff1f\u5728\u5b8c\u6574\u6307\u5357\u4e2d\u4e86\u89e3\u4f60\u9700\u8981\u7684\u6240\u6709\u5185\u5bb9\u3002"},{"@type":["Person"],"@id":"https://ahrefs.com/blog/zh/#/schema/person/03777ed319d5dcc465ad6764ba7b7d31","name":"Joshua Hardwick","image":{"@type":"ImageObject","@id":"https://ahrefs.com/blog/zh/#authorlogo","url":"https://secure.gravatar.com/avatar/a8a27ac50ee9b44d2828afe3c1fbe229?s=96&d=mm&r=g","caption":"Joshua Hardwick"},"description":"Ahrefs\u5185\u5bb9\u8425\u9500\u603b\u76d1\u3002\u4ed6\u8d1f\u8d23\u786e\u4fdd\u6211\u4eec\u53d1\u5e03\u7684\u6bcf\u7bc7\u6587\u7ae0\u90fd\u662f\u795e\u4f5c\u3002The SEO Project\u521b\u59cb\u4eba\u3002","sameAs":["https://twitter.com/joshuachardwick"]}]}</script> <link rel='dns-prefetch' href='//ahrefs.com' /><link rel='dns-prefetch' href='//ajax.googleapis.com' /><link rel='dns-prefetch' href='//s.w.org' /><link rel="alternate" type="application/rss+xml" title=" &raquo; Feed" href="https://ahrefs.com/blog/zh/feed/" /><link rel="alternate" type="application/rss+xml" title=" &raquo; Comments Feed" href="https://ahrefs.com/blog/zh/comments/feed/" /><link rel="alternate" type="application/rss+xml" title=" &raquo; Nofollow链接 VS Follow链接：所有你需要了解的知识 Comments Feed" href="https://ahrefs.com/blog/zh/nofollow-links/feed/" /> <script type="text/javascript">window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/12.0.0-1\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/12.0.0-1\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/ahrefs.com\/blog\/zh\/wp-includes\/js\/wp-emoji-release.min.js?ver=5.3"}};!function(e,a,t){var r,n,o,i,p=a.createElement("canvas"),s=p.getContext&&p.getContext("2d");function c(e,t){var a=String.fromCharCode;s.clearRect(0,0,p.width,p.height),s.fillText(a.apply(this,e),0,0);var r=p.toDataURL();return s.clearRect(0,0,p.width,p.height),s.fillText(a.apply(this,t),0,0),r===p.toDataURL()}function l(e){if(!s||!s.fillText)return!1;switch(s.textBaseline="top",s.font="600 32px Arial",e){case"flag":return!c([127987,65039,8205,9895,65039],[127987,65039,8203,9895,65039])&&(!c([55356,56826,55356,56819],[55356,56826,8203,55356,56819])&&!c([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]));case"emoji":return!c([55357,56424,55356,57342,8205,55358,56605,8205,55357,56424,55356,57340],[55357,56424,55356,57342,8203,55358,56605,8203,55357,56424,55356,57340])}return!1}function d(e){var t=a.createElement("script");t.src=e,t.defer=t.type="text/javascript",a.getElementsByTagName("head")[0].appendChild(t)}for(i=Array("flag","emoji"),t.supports={everything:!0,everythingExceptFlag:!0},o=0;o<i.length;o++)t.supports[i[o]]=l(i[o]),t.supports.everything=t.supports.everything&&t.supports[i[o]],"flag"!==i[o]&&(t.supports.everythingExceptFlag=t.supports.everythingExceptFlag&&t.supports[i[o]]);t.supports.everythingExceptFlag=t.supports.everythingExceptFlag&&!t.supports.flag,t.DOMReady=!1,t.readyCallback=function(){t.DOMReady=!0},t.supports.everything||(n=function(){t.readyCallback()},a.addEventListener?(a.addEventListener("DOMContentLoaded",n,!1),e.addEventListener("load",n,!1)):(e.attachEvent("onload",n),a.attachEvent("onreadystatechange",function(){"complete"===a.readyState&&t.readyCallback()})),(r=t.source||{}).concatemoji?d(r.concatemoji):r.wpemoji&&r.twemoji&&(d(r.twemoji),d(r.wpemoji)))}(window,document,window._wpemojiSettings);</script> <link rel='stylesheet' id='a3a3_lazy_load-css'  href='//ahrefs.com/blog/zh/wp-content/uploads/sass/a3_lazy_load.min.css?ver=1543958215' type='text/css' media='all' /> <!--[if !IE]><!--><link rel='stylesheet' id='tablepress-responsive-tables-flip-css'  href='https://ahrefs.com/blog/zh/wp-content/plugins/tablepress-responsive-tables/css/tablepress-responsive-flip.min.css?ver=1.5' type='text/css' media='all' /> <!--<![endif]--> <script type='text/javascript' src='https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=null'></script> <link rel='https://api.w.org/' href='https://ahrefs.com/blog/zh/wp-json/' /><link rel='shortlink' href='https://ahrefs.com/blog/zh/?p=533' /><link rel="alternate" type="application/json+oembed" href="https://ahrefs.com/blog/zh/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fahrefs.com%2Fblog%2Fzh%2Fnofollow-links%2F" /><link rel="alternate" type="text/xml+oembed" href="https://ahrefs.com/blog/zh/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fahrefs.com%2Fblog%2Fzh%2Fnofollow-links%2F&#038;format=xml" /><link rel="alternate" href="https://ahrefs.com/blog/nofollow-links/" hreflang="x-default" /><link rel="alternate" href="https://ahrefs.com/blog/zh/nofollow-links/" hreflang="zh-Hans" /><link rel="alternate" href="https://ahrefs.com/blog/nofollow-links/" hreflang="en" /><link rel="alternate" href="https://ahrefs.com/blog/de/nofollow-links/" hreflang="de" /></head><body class="post-template-default single single-post postid-533 single-format-standard"><header id="header"><div class="container"><div class="row"><div class="col-lg-12 col-md-12 col-sm-12 col-xs-12"><div class="clearfix"><div class="logo"><h2>&nbsp;<a class="ahrefs" href="https://ahrefs.com" target="_blank" rel="noopener" title="SEO Blog by Ahrefs"></a><a class="blog" href="https://ahrefs.com/blog/zh/" target="_blank" rel="noopener" title="SEO Blog by Ahrefs"></a></h2></div><div class="tagline"> <a href="https://ahrefs.com/zh/" target="_blank" rel="noopener">Ahrefs</a>是一个基于海量关键词、外链、以及内容数据的营销工具箱</div></div></div></div></div></header><div id="container"><div id="content"><div id="post-533" class="post-holder clearfix post-533 post type-post status-publish format-standard has-post-thumbnail hentry category-general-seo odd" ><div class="form-slide" id="slideForm"><div class="form-slide-container"> <svg class="close" id="form-slide-close" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"> <g fill="none"><path d="M0 0h14v14h-14z"/> <path fill="#333" fill-rule="nonzero" d="M8.417 7l4.583-4.583-1.417-1.417-4.583 4.583-4.583-4.583-1.417 1.417 4.583 4.583-4.583 4.583 1.417 1.417 4.583-4.583 4.583 4.583 1.417-1.417z"/> </g> </svg><div class="form-inner"><form onsubmit="return false"> <input type="hidden" name="email" value=""><div id="sImg" class="form-slide-inner default"><h4 id="subscrHeader" style="color:#000">Enjoyed the Read?</h4><p id="subscrText" style="padding: 0px">Don’t miss our next article!</p><div class="mc4wp-form-fields"><div class="form-group" id="formGroup"> <label class="sr-only"><span class="screen-reader-text">Email Subscription</span></label> <input type="email" id="sMail" placeholder="Enter your email" required=""><div class="mc4wp-form-message"> <span id="sRes"></span></div><div class="bg-submit"> <input id="sSubscrBtn" name="sSubscrBtn" type="submit" class="btn btn-primary" value=""></div></div></div><div><p class="mc4wp-response"></p></div></div></form></div></div></div> <script>$("#sSubscrBtn").click(function(){        $("#sSubscrBtn").attr('disabled', true);        $.post('/blog/mch_subscr.php', { sMail:$("#sMail").val(), sToken:"ce9b49c752f54413174de1cf19b7d2002fa1894f143500109da6c07a60ec4c65", email:$("#email").val() },  function(data, textStatus) {            if (typeof(data)!=='undefined' && typeof(data.res)!=='undefined')            {                $("#sRes").html("");                var gotItBtnSrc = "<div class='' onclick='$(\"#slideForm\").addClass(\"slideOut\");'> <input type='submit' class='btn btn-primary' style='width:100%' value='Got it!'></div>";                if (data.res===true) {                    // success                    $("#sImg").attr('class', 'form-slide-inner success');                    $("#subscrHeader").html("Thanks!");                    $("#subscrText").html("Please verify your email.");                    $("#formGroup").html(gotItBtnSrc);                    Cookies.set('slHide', '1', { expires: 10 });                    Cookies.set('slNum', '0', { expires: 100 });                } else {                    if (data.error==='subscribed') {                        // subscribed                        $("#sImg").attr('class', 'form-slide-inner subscribed');                        $("#subscrHeader").html("Whoa!");                        $("#subscrText").html("Looks like you're subscribed to our blog already.<img src='/blog/wp-content/themes/Ahrefs-4/images/hand_2x.png' width='18px' style='margin-top:-5px'>");                        $("#formGroup").html(gotItBtnSrc);                        Cookies.set('slHide', '1', { expires: 90 });                        Cookies.set('slNum', '0', { expires: 100 });                    } else {                        // custom error                        $("#sImg").attr('class', 'form-slide-inner error');                        $("#subscrHeader").html("Enjoyed the Read?");                        $("#subscrText").html("Don't miss our next article!");                        $("#sRes").html('<span style="color:red">' + data.error + '</span>');                    }                }            }        }, "json");        // $.post("/blog/set_v.php", {uAct:1});        $("#sSubscrBtn").attr('disabled', false);        return false;    });    var sPopup = false;    $("#mc4wp-form-1").submit(function(e){        $.post("/blog/set_v.php", {uAct:1});        return true;    });$(function() {        if (Cookies.get('slHide')==='1') {            return 0;        }var slideForm = $("#slideForm");var target = document.querySelector('.post-footer')if ('IntersectionObserver' in window) {var options = {root: null,rootMargin: '0px',threshold: 0.1}var callback = function(entries, observer) {entries.forEach(function(entry){if (entry.intersectionRatio > 0) {slideForm.addClass("slideIn");                        if (!sPopup) {                            $.post("/blog/set_v.php", {uAct:0});                            $.getJSON('/ajax/user/subscription/email', {}, function(data) {                                $.each(data, function(index, value) {                                    if (index==='email' && value.length>7) {                                        $("#sRes").html("<span class='pre-filled'>We know your email because you have an account with Ahrefs <img src='/blog/wp-content/themes/Ahrefs-4/images/smile_2x.png' /></span>");                                        $("#sMail").val(value);                                    }                                });                            });                            sPopup = true;                        }}});};var observer = new IntersectionObserver(callback, options);observer.observe(target);}$("#form-slide-close").on("click", function(){            if (Cookies.get('slHide')!=='1') {                if (Cookies.get('slNum')=='2') {                    // if click on "close" the second time                    Cookies.set('slHide', '1', { expires: 10 });                    Cookies.set('slNum', '3', { expires: 100 });                } else if(Cookies.get('slNum')=='3') {                    Cookies.set('slHide', '1', { expires: 90 });                    Cookies.set('slNum', '0', { expires: 100 });                } else {                    // if click on "close" the first time                    Cookies.set('slHide', '1', { expires: 1 });                    Cookies.set('slNum', '2', { expires: 100 });                }            }            $.post("/blog/set_v.php", {uAct:2});$(".form-slide").addClass("slideOut").removeClass("slideIn");});})</script> <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization" style="display:none"><div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject"> <img src="https://cdn.ahrefs.com/images/logo/logo_180x80.jpg"/><meta itemprop="url" content="https://cdn.ahrefs.com/images/logo/logo_180x80.jpg"><meta itemprop="width" content="180"><meta itemprop="height" content="80"></div><meta itemprop="name" content="Ahrefs"><meta itemprop="url" content="https://ahrefs.com"></div> <script>function ss(type,socId,pl) { $.post("/blog/set_ss.php", {type:type, socId:socId, pl:pl}); }</script> <div class="share-post"><div class="twitter sharrre sharrre-twitter-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Tweet" onclick="ss(0,0,1);"><div class="box"><div class="share"><i class="fa fa-twitter"></i></div></div></div><div class="facebook sharrre sharrre-facebook-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Like" onclick="ss(0,1,1);"><div class="box"><div class="share"><i class="fa fa-facebook"></i></div></div></div><div class="linkedin sharrre sharrre-linkedin-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Share" onclick="ss(0,2,1);"><div class="box"><div class="share"><i class="fa fa-linkedin"></i></div></div></div></div>  <script>jQuery(document).ready(function (jQuery) {        jQuery('.sharrre-facebook-533').each(function () {            var self = this;            jQuery(this).sharrre({                share: {                    facebook: true                },                enableCounter: false,                enableHover: false,                template: '.',                click: function (api, options) {                    api.simulateClick();                    api.openPopup('facebook');                }            });        });        jQuery('.sharrre-twitter-533').each(function () {            var self = this;            jQuery(this).sharrre({                share: {                    twitter: true                },                enableCounter: false,                enableHover: false,                buttons: {twitter: {via: 'ahrefs', related: 'ahrefs'}},                template: '.',                click: function (api, options) {                    api.simulateClick();                    api.openPopup('twitter');                }            });        });        jQuery('.sharrre-linkedin-533').each(function () {            var self = this;            jQuery(this).sharrre({                share: {                    linkedin: true                },                enableCounter: false,                enableHover: false,                template: '.',                click: function (api, options) {                    api.simulateClick();                    api.openPopup('linkedin');                }            });        });    });</script> <div class="share-post-mobile"><div class="twitter sharrre sharrre-twitter-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Tweet" onclick="ss(1,0);"><div class="box"><div class="share"><i class="fa fa-twitter"></i></div></div></div><div class="facebook sharrre sharrre-facebook-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Like" onclick="ss(1,1);"><div class="box"><div class="share"><i class="fa fa-facebook"></i></div></div></div><div class="linkedin sharrre sharrre-linkedin-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Share" onclick="ss(1,2);"><div class="box"><div class="share"><i class="fa fa-linkedin"></i></div></div></div></div><div class="top-section  with-image"><div class="container"><div class="row"><div class="col-lg-12 col-md-12 col-sm-12 col-xs-12"><div class="header-thumbnail"> <img width="2320" height="800" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-header-1.jpg" class="attachment-header-thumbnail size-header-thumbnail" alt="Nofollow Links" itemprop="image" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-header-1.jpg 2320w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-header-1-768x265.jpg 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-header-1-680x234.jpg 680w" sizes="(max-width: 2320px) 100vw, 2320px" /></div><header class="post-header"><div class="post-category"><a href="https://ahrefs.com/blog/zh/category/general-seo/" target="_blank" rel="tag noopener">SEO汇总</a></div> <a  href="https://ahrefs.com/blog/zh/nofollow-links/" target="_blank" rel="noopener"></a><h1 class="entry-title">Nofollow链接 <span class="caps">VS</span> Follow链接：所有你需要了解的知识</h1><div class="post-meta"> <span class="post-author vcard author" itemprop="author"> <a href="https://ahrefs.com/blog/zh/author/joshua-hardwick/" title="Posts by Joshua Hardwick" rel="author"> <span class="fn">Joshua Hardwick</span> </a> </span> <span class="post-date published updated" itemprop="datePublished">July 30, 2019</span></div></header></div></div></div></div><div class="post-container"><div class="container top-inner"><div class="row"><div class="col-lg-12 col-md-12 col-sm-12 col-xs-12"><div class="post-content"><div class="author-desktop"><div class="author-meta"><div class="author-avatar"><img src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://secure.gravatar.com/avatar/a8a27ac50ee9b44d2828afe3c1fbe229?s=85&#038;d=mm&#038;r=g" width="85" height="85" alt="Avatar" class="lazy lazy-hidden avatar avatar-85 wp-user-avatar wp-user-avatar-85 photo avatar-default" /><noscript><img src="https://secure.gravatar.com/avatar/a8a27ac50ee9b44d2828afe3c1fbe229?s=85&#038;d=mm&#038;r=g" width="85" height="85" alt="Avatar" class="avatar avatar-85 wp-user-avatar wp-user-avatar-85 photo avatar-default" /></noscript></div><div class="author-name"> <a href="https://ahrefs.com/blog/zh/author/joshua-hardwick/" target="_blank" title="Posts by Joshua Hardwick" rel="author noopener">Joshua Hardwick</a></div><div class="author-desc"> Ahrefs内容营销总监。他负责确保我们发布的每篇文章都是神作。The SEO Project创始人。</div><div class="author-social"> <a class="author-link" href="http://www.theseoproject.org/" target="_blank"><span class="glyphicon glyphicon-home"></span></a><a href="https://twitter.com/joshuachardwick" target="_blank"><i class="fa fa-twitter"></i></a></div></div><div class="article-stats"><div class="share-post-top-bottom"><h3>分享</h3><div class="twitter sharrre sharrre-twitter-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Tweet" onclick="ss(0,0,0);"><div class="box"><div class="share"><i class="fa fa-twitter"></i></div></div></div><div class="facebook sharrre sharrre-facebook-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Like" onclick="ss(0,1,0);"><div class="box"><div class="share"><i class="fa fa-facebook"></i></div></div></div><div class="linkedin sharrre sharrre-linkedin-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Share" onclick="ss(0,2,0);"><div class="box"><div class="share"><i class="fa fa-linkedin"></i></div></div></div></div></div></div><div id="nav-anchor"></div><div class="post-navigation"><div class="nav-title">快速链接</div><ul></ul></div> <span><div class="intro-txt">rel=”nofollow”标签是html标签中使用比较广泛的一种。尤其是SEO从业人员对于这个标签应该再熟悉不过了。这个教程中会让你了解所有关于Nofollow链接的知识。</div><p>Nofollow链接不是什么新的东西，它已经存在了14年了。</p><p>如果你关心你的网站在搜索引擎中的表现，那么知道什么时候应该使用、或者什么时候不该使用nofollow链接是至关重要的。</p><p>在本指南中，我将解释nofollow链接是如何形成的，它们如何帮助我们进行SEO优化，以及如何正确使用它们，避免被谷歌算法惩罚。</p><p>首先我们从基础开始说起。<br></p><div class="post-nav-link clearfix" id="section1"><a class="subhead-anchor" data-tip="tooltip__copielink" rel="#section1"><svg width="19" height="19" viewBox="0 0 14 14" style><g fill="none" fill-rule="evenodd"><path d="M0 0h14v14H0z" /><path d="M7.45 9.887l-1.62 1.621c-.92.92-2.418.92-3.338 0a2.364 2.364 0 0 1 0-3.339l1.62-1.62-1.273-1.272-1.62 1.62a4.161 4.161 0 1 0 5.885 5.884l1.62-1.62L7.45 9.886zM5.527 5.135L7.17 3.492c.92-.92 2.418-.92 3.339 0 .92.92.92 2.418 0 3.339L8.866 8.473l1.272 1.273 1.644-1.643A4.161 4.161 0 1 0 5.897 2.22L4.254 3.863l1.272 1.272zm-.66 3.998a.749.749 0 0 1 0-1.06l2.208-2.206a.749.749 0 1 1 1.06 1.06L5.928 9.133a.75.75 0 0 1-1.061 0z" style /></g></svg></a><div class="link-text"><h2 id="Nofollow">什么是Nofollow链接？</h2></div></div> Nofol­low链接指的是超链接代码中有 rel=“nofollow”标记的链接。<p>这些链接不会影响网站的搜索引擎排名。因为<a href="https://support.google.com/webmasters/answer/96569?hl=en" target="_blank" rel="noopener noreferrer">Google不会通过它传递PR值</a>。事实上，谷歌甚至都没有抓取nofollow链接。</p><p>推荐阅读：<a href="https://ahrefs.com/blog/google-pagerank/" target="_blank" rel="noopener">谷歌PR值没有死：为什么依然有用？</a></p><p>Nofol­low链接 <span class="caps">VS</span> Fol­low链接</p><p>对于正常的网站访客来说，nofollow和follow看起来很像。</p><p>在这句话中的<a href="https://ahrefs.com/" target="_blank" rel="noopener">蓝色链接</a>是fol­low链接。</p><p>这句话中的<a href="https://ahrefs.com/" target="_blank" rel="nofollow noopener">蓝色链接则</a>是nofollow链接。如果你通过html进行查看的话，才会发现差别。</p><p><strong>Dofol­low链接:</strong></p><pre>&lt;a href="https://ahrefs.com"&gt;蓝色链接&lt;/a&gt;</pre><p><strong>Nofol­low链接:</strong></p><pre>&lt;a href="https://ahrefs.com" rel="nofollow"&gt;蓝色链接&lt;/a&gt;</pre><p>除了rel =“nofollow”标记之外，其他部分的HTML是相同的。</p><p>你虽然可以通过添加meta标签的方式去nofollow页面上的所有链接。但是使用nofollow标记是更常用的方法，因为你可以选择让一个特殊的链接传不递权重，而让其它的链接传递权重。</p><p>不太清楚为什么你会这么做，但是我们还是先来了解下nofollow的历史。</p><div class="post-nav-link clearfix" id="section1"><a class="subhead-anchor" data-tip="tooltip__copielink" rel="#section1"><svg width="19" height="19" viewBox="0 0 14 14" style><g fill="none" fill-rule="evenodd"><path d="M0 0h14v14H0z" /><path d="M7.45 9.887l-1.62 1.621c-.92.92-2.418.92-3.338 0a2.364 2.364 0 0 1 0-3.339l1.62-1.62-1.273-1.272-1.62 1.62a4.161 4.161 0 1 0 5.885 5.884l1.62-1.62L7.45 9.886zM5.527 5.135L7.17 3.492c.92-.92 2.418-.92 3.339 0 .92.92.92 2.418 0 3.339L8.866 8.473l1.272 1.273 1.644-1.643A4.161 4.161 0 1 0 5.897 2.22L4.254 3.863l1.272 1.272zm-.66 3.998a.749.749 0 0 1 0-1.06l2.208-2.206a.749.749 0 1 1 1.06 1.06L5.928 9.133a.75.75 0 0 1-1.061 0z" style /></g></svg></a><div class="link-text"><h2>Rel=“nofollow” 的历史</h2></div></div><p>谷歌最初<a href="https://googleblog.blogspot.com/2005/01/preventing-comment-spam.html" target="_blank" rel="noopener noreferrer">提出</a>&nbsp;nofollow的做法是在2005年，为了打击垃圾评论外链。</p><blockquote class="small"><div class="quote-content"> 如果你是博主（或博客读者），你会非常熟悉那些在留言框中留下 “访问我的折扣药品网站” 链接的那些内容。 这些链接的目的就是用来提高自己网站搜索引擎排名。这就是所谓的垃圾评论，我们也不喜欢它，我们一直在测试阻止它的新标签。从现在开始，当Google在超链接上看到属性（rel =“nofollow”）时，<strong>这些链接将不会获得任何信用</strong>。这并不是说不信任所有的评论链接。这只是一种方法，可以确保垃圾链接发送者不会滥用博客评论，引用和引荐列表等公共区域。</div></blockquote><p>不久之后，<a href="https://web.archive.org/web/20050203015651/http://www.ysearchblog.com/archives/000069.html" target="_blank" rel="noopener noreferrer">Yahoo</a>、<a href="https://web.archive.org/web/20150603030936/http://blogs.bing.com/webmaster/2008/06/03/robots-exclusion-protocol-joining-together-to-provide-better-documentation" target="_blank" rel="noopener noreferrer">Bing</a>和其他一些搜索引擎也宣布了它们对no­fol­low标签的承诺。</p><div class="recommendation"><div class="recommendation-title">重要的提示</div><div class="recommendation-content"><p>关于no­fol­low的解释在不同的搜索引擎之间有所不同。<a href="https://en.wikipedia.org/wiki/Nofollow#Interpretation_by_the_individual_search_engines" target="_blank" rel="noopener noreferrer">这里</a>是一个显示相互之间差异的表格。</p></div></div><p>如今，和许多其它的CMS程序一样，WordPress程序在默认情况下会将nofollow标记添加到评论链接中。因此，即使你之前从未听说过nofollow链接，请放心，博客上的任何垃圾评论可能都没有办法获得任何SEO的权重加成。</p><p>但是，如果您担心您的评论可能不会被忽视，请按以下方式仔细检查：</p><ol><li>找到一个评论链接</li><li>右键单击该链接</li><li>点击“审查元素”</li><li>查看高亮显示的HTML代码</li></ol><p><img class="lazy lazy-hidden wp-image-518" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-2.gif" alt="nofollow 2"></p><noscript><img class="wp-image-518" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-2.gif" alt="nofollow 2"></noscript><p>如果你看到的 rel=“nofollow”标记，说明这个链接是nofollow的，否则就是follow状态。</p><p>如果你不习惯看HTML代码的话，建议安装nofollow的Chrome扩展程序，可在浏览网页时高亮显示所有nofollow链接。</p><p><img class="lazy lazy-hidden wp-image-532" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-19.png" alt="pasted image 0 19"></p><noscript><img class="wp-image-532" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-19.png" alt="pasted image 0 19"></noscript><p>看到了吗？好，还是回到历史的话题上面来。</p><h2>2009年：谷歌打击刻意的链接植入</h2><p>PR值通过<a href="https://ahrefs.com/blog/internal-links-for-seo/" target="_blank" rel="noopener">内部链接</a>（从网站上的一个页面到另一个页面的链接）在网站上流动。</p><p>例如，本文的一些PR值通过类似<a href="https://ahrefs.com/" target="_blank" rel="noopener">这样的超链接</a>流向我们网站上的其他页面。一般来说，较高的PR值等同于更高的排名。 Gary Ill­y­ses去年也证实了这一点。</p><p><img class="lazy lazy-hidden wp-image-529" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/1.png" alt="1"></p><noscript><img class="wp-image-529" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/1.png" alt="1"></noscript><p>但是，PR值只能通过follow链接进行传输，而不是通过nofollow链接传输。</p><p>情况总是如此，但是多年来PR值在页面上的follow链接之间共享的方式已经发生了变化。</p><p>在2009年之前，它的工作方式如下：如果页面上有<strong>三个链接</strong>，其中<strong>一个</strong>链接是nofollow，则总的PR值在<strong>其它两个</strong>fol­low链接之间分配。</p><p><img class="lazy lazy-hidden wp-image-530" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17.png" alt="pasted image 0 17" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17-768x975.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17-335x425.png 335w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-530" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17.png" alt="pasted image 0 17" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17-768x975.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-17-335x425.png 335w" sizes="(max-width: 900px) 100vw, 900px"></noscript><p>不幸的是，有些人开始利用这种技术性来通过刻意的在页面中植入网站的链接，利用PR值传递来操纵排名。</p><p>换句话说，它们nofollow了指向不重要页面的链接，最大程度的提高了指向“高转化”页面链接的权重传递。</p><p>谷歌在2009年宣布一个改动，将这种做法扼杀在萌芽状态：</p><blockquote class="small"><div class="quote-content"> 假设你得一个页面拥有“10个单位的PR值”，同时页面上有个10个外部链接？其中5个链接是nofollow链接。[…] 最初，谷歌会将10个单位的PR值平均分给5个follow链接，一个链接2个单位的PR值。[…] <strong>但是在一年前，谷歌更改了计算方式后，每个链接都会平均享有PR值，只是nofollow的链接不传递权重而以。</strong></div></blockquote><p>以下是谷歌变化前后说明的说明图</p><p><img class="lazy lazy-hidden wp-image-515" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7.png" alt="pasted image 0 7" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7-768x929.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7-351x425.png 351w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-515" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7.png" alt="pasted image 0 7" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7-768x929.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-7-351x425.png 351w" sizes="(max-width: 900px) 100vw, 900px"></noscript><div class="recommendation"><div class="recommendation-title">重要的提示</div><div class="recommendation-content"><p>PR值是一个复杂的东西。谷歌做出这一改变已有十年了。虽然近年来他们尚未公开宣布对PR值的工作方式有任何进一步的改变。但至少在背后，确实在发生一些变化。</p></div></div><p>虽然刻意植入链接获取PR值做法已经失效，但是针对部分链接进行nofollow的设置有助于谷歌更好的抓取你的页面。<strong>因为no­fol­low链接谷歌是不抓取的</strong>。</p><blockquote class="small"><div class="quote-content">搜索引擎蜘蛛不会在论坛上登录或注册为会员，因此你没有理由邀请谷歌蜘蛛抓取“注册”或“登录”页面。在这些链接上使用nofollow可让谷歌蜘蛛更有效的抓取那些值得被索引的页面。</div></blockquote><p>这个话题有点深，我就不在这里继续讨论了。</p><p><strong>推荐阅读：</strong><a href="https://www.contentkingapp.com/academy/crawl-budget/" target="_blank" rel="noopener noreferrer">SEO中的抓取预算：终极参考指南</a></p><h2>2013年起：Google打击付费链接</h2><p>Google将通过买卖链接传递PR值归类为违反其网站站长指南的行为。</p><p>因此，<strong>所有付费链接应该都是no­fol­low链接</strong>。</p><p>这种情况多年来一直如此，甚至早在2013年之前。</p><p>但是，从我所看到的情况来看，谷歌在这个时候越来越关注未公开的付费链接对他们算法的影响.…..并且从那时起就一直如此。</p><p>Matt Cutts在2013年视频中披露谷歌深入研究付费链接的原因：</p><div class="arve-wrapper arve-normal-wrapper arve-youtube-wrapper " itemscope itemtype="http://schema.org/VideoObject" style="background-image: url(//img.youtube.com/vi/1SmlsfSqmOw/0.jpg);"><div class="arve-embed-container"><iframe id="arve-iframe-1" class="arve-inner arve-hidden" data-src="//www.youtube.com/embed/1SmlsfSqmOw?iv_load_policy=3&amp;modestbranding=1&amp;rel=0&amp;wmode=transparent&amp;autoplay=1" frameborder="0" scrolling="no" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe><button class="arve-inner arve-play-background arve-iframe-btn" data-target="arve-iframe-1"></button></div></div><p><a href="https://www.youtube.com/watch?v=1SmlsfSqmOw" target="_blank" rel="noopener" class="arve-hidden">https://www.youtube.com/watch?v=1SmlsfSqmOw</a></p><p>总结一下就是：谷歌希望你通过内容质量“<strong>获得</strong>”链接，而不是“<strong>购买</strong>”链接。</p><blockquote class="small"><div class="quote-content">大家会把链接行为当成一种投票，他们分享链接是因为这个链接的内容有趣，或者是可以激发他们的激情。他们希望把这个链接内容分享给自己的朋友。</div></blockquote><p>问题是某些付费链接与你通过内容质量获得的链接没什么不同。你可以站在一个没有进行付费链接的用户角度去判断，付费链接和自然链接之间有什么区别。</p><p>从表面上看，两个链接看起来都是一样的。这就是为什么需要一种方式辨别是否是付费链接。</p><p>你可以这么去思考这个问题：</p><p>假设你想要获得一个奥斯卡小金人，那么现在有两个选择。</p><p><strong>选择1：</strong>致力于演艺，不断磨练你的技术，多年努力工作。</p><p><strong>选择2</strong>：<a href="https://www.amazon.com/Gold-Award-Trophies-Trophy-Statues/dp/B06XFZ61BV" target="_blank" rel="noopener noreferrer">在Amazon花8.97美金买6个.…</a></p><p>Nofollow后的付费接对于谷歌来说，就相当于是这种假的奥斯卡小金人一样。它代表着，这个链接不是通过质量，或者努力换来的。而是一种非正常，不值得被奖励的手段。</p><div class="post-nav-link clearfix" id="section1"><a class="subhead-anchor" data-tip="tooltip__copielink" rel="#section1"><svg width="19" height="19" viewBox="0 0 14 14" style><g fill="none" fill-rule="evenodd"><path d="M0 0h14v14H0z" /><path d="M7.45 9.887l-1.62 1.621c-.92.92-2.418.92-3.338 0a2.364 2.364 0 0 1 0-3.339l1.62-1.62-1.273-1.272-1.62 1.62a4.161 4.161 0 1 0 5.885 5.884l1.62-1.62L7.45 9.886zM5.527 5.135L7.17 3.492c.92-.92 2.418-.92 3.339 0 .92.92.92 2.418 0 3.339L8.866 8.473l1.272 1.273 1.644-1.643A4.161 4.161 0 1 0 5.897 2.22L4.254 3.863l1.272 1.272zm-.66 3.998a.749.749 0 0 1 0-1.06l2.208-2.206a.749.749 0 1 1 1.06 1.06L5.928 9.133a.75.75 0 0 1-1.061 0z" style /></g></svg></a><div class="link-text"><h2>Nofollow链接对SEO有影响吗？</h2></div></div><p>让我们来回顾一下谷歌是如何处理no­fol­low链接的</p><blockquote class="small"><div class="quote-content">谷歌不会通过这个链接传递任何的权重或者是锚文本。</div></blockquote><p>看上去有了定论，直到你看了它前面的一句话。</p><blockquote class="small"><div class="quote-content"><strong>通常，我们不会跟踪这些链接。</strong>谷歌不会通过这个链接传递任何的权重或者是锚文本。</div></blockquote><p>通常，并不是绝对，我认为在第一顶情况下，谷歌依然会跟踪nofollow链接。</p><p>具体是什么情况呢？没有人知道。</p><p>有些人认为所有的nofollow链接仍然转移一些PR值。有些人认为谷歌将PR值转移到一些nofollow链接上，但不是所有的链接。其他人则认为，人们太在意谷歌的说辞了，<a href="https://web.archive.org/web/20130714093949/https://support.google.com/webmasters/answer/96569?hl=en#" target="_blank" rel="noopener noreferrer">这些说辞已经7年没有变化了</a>。</p><p>早在今年早些时候，我们<a href="https://ahrefs.com/blog/links-with-traffic-study/" target="_blank" rel="noopener">研究了44,589个</a>搜索引擎结果页面（<span class="caps">SERP</span>）。目的是为了研究谷歌排名和各类外链要素之间的关系。其中一个要素就是dofollow链接数量。</p><p>下面是我们发现的结果:</p><p><img class="lazy lazy-hidden" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/130fc255-9589-4802-9b1b-0fa6c46b696b/how-rankings-correlate-with-backlink-metrics_cn.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45PVRWYC4M%2F20190729%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190729T023159Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEPD%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCPvHIeyFoQMZ48GjQYIkrcukhaBvgIABtirLs9CjOGtwIhAIDcXEZRIvADGdGR8BlBXpfsHkMvu9hl2lpuEFuqYRkiKtoDCGkQABoMMjc0NTY3MTQ5MzcwIgw9fYb099dhlrR3HN0qtwPp5dSp85P65e8YKI4eEzwVj6aV6yxW5SbItuvQu9wSQRxRmNxPZRM%2BxllnTqsGvfL7Jksh9k3970DSeNAldJLEhurR0eucsL6sxXvcjhtA3TUWYmC7Sd%2BrE2a0N1MGazFXQq3vGhROm%2BkfiXFgEqw7fFb0HcQM49gdk5pgYZ1GMQ5CExOss6%2FaCp8KweFmIaUtdOdh1fn5m23GgApyn5g4cfgCfaVR%2FIfKRh1d%2BVNaophyp%2FQGoyJwVjyujTK12E3lYU4oYGjlsFVzd2UcJwTlmQnFmZu27bYgk%2B0z65dBo2wNUKH3CaGwXc1FLN%2FegnPjgtuGjGZSgvKoq5LjQ1EyD%2Fbti6LHil6LvsFU%2FINt%2Bz8drC%2B0D9NG1aqUJCctnouy25P%2BzBYZMIPfOM0Q46dyqWwwtLaYD5Ha6B2fEHL%2ByvEurDo%2BXI5QYKGfn%2FHAJZFmtZxjtaRb9SAoHhr%2FA0w1oxQgnJqGFpXJxJ%2B3LWQpm2h9JSD1nt4uwZtroFVjIZgXJnI166q2mOqy1hTO%2BLSeATdLIcAq8Ngzt2yGPkkX7s4z%2FPo%2BmHNkTIshWtitMcrCUUNp0htoMKvn%2BOkFOrMBysLR3f2rHp6nI%2BQViw1tLWn%2BxF5iLr0bGoySv3IkVPrSqfdlEkXt9PVbur3UexXNJDZbN9sL5a6UD7nAWHbGkGClhiP%2BCuB8WIch19gtnl0%2B2COKbgozNKk9ymxvefMw091BGuLhZsFO8YpcaXe%2F5LP02URJcqqWc%2B4hq4m0ikk%2F%2Bu2I2xmfIP73EYFt5H4wIq8mYfkKmj6a9w4012TiC8PlGQGoPe9uhI%2Fhgjq9TNEfkRk%3D&amp;X-Amz-Signature=acb94d77f38fc4cd62ff3d362e98e2b8f054aa1996a0c4de126debb233fb3814&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22how-rankings-correlate-with-backlink-metrics_cn.png%22"></p><noscript><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/130fc255-9589-4802-9b1b-0fa6c46b696b/how-rankings-correlate-with-backlink-metrics_cn.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45PVRWYC4M%2F20190729%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190729T023159Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEPD%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCPvHIeyFoQMZ48GjQYIkrcukhaBvgIABtirLs9CjOGtwIhAIDcXEZRIvADGdGR8BlBXpfsHkMvu9hl2lpuEFuqYRkiKtoDCGkQABoMMjc0NTY3MTQ5MzcwIgw9fYb099dhlrR3HN0qtwPp5dSp85P65e8YKI4eEzwVj6aV6yxW5SbItuvQu9wSQRxRmNxPZRM%2BxllnTqsGvfL7Jksh9k3970DSeNAldJLEhurR0eucsL6sxXvcjhtA3TUWYmC7Sd%2BrE2a0N1MGazFXQq3vGhROm%2BkfiXFgEqw7fFb0HcQM49gdk5pgYZ1GMQ5CExOss6%2FaCp8KweFmIaUtdOdh1fn5m23GgApyn5g4cfgCfaVR%2FIfKRh1d%2BVNaophyp%2FQGoyJwVjyujTK12E3lYU4oYGjlsFVzd2UcJwTlmQnFmZu27bYgk%2B0z65dBo2wNUKH3CaGwXc1FLN%2FegnPjgtuGjGZSgvKoq5LjQ1EyD%2Fbti6LHil6LvsFU%2FINt%2Bz8drC%2B0D9NG1aqUJCctnouy25P%2BzBYZMIPfOM0Q46dyqWwwtLaYD5Ha6B2fEHL%2ByvEurDo%2BXI5QYKGfn%2FHAJZFmtZxjtaRb9SAoHhr%2FA0w1oxQgnJqGFpXJxJ%2B3LWQpm2h9JSD1nt4uwZtroFVjIZgXJnI166q2mOqy1hTO%2BLSeATdLIcAq8Ngzt2yGPkkX7s4z%2FPo%2BmHNkTIshWtitMcrCUUNp0htoMKvn%2BOkFOrMBysLR3f2rHp6nI%2BQViw1tLWn%2BxF5iLr0bGoySv3IkVPrSqfdlEkXt9PVbur3UexXNJDZbN9sL5a6UD7nAWHbGkGClhiP%2BCuB8WIch19gtnl0%2B2COKbgozNKk9ymxvefMw091BGuLhZsFO8YpcaXe%2F5LP02URJcqqWc%2B4hq4m0ikk%2F%2Bu2I2xmfIP73EYFt5H4wIq8mYfkKmj6a9w4012TiC8PlGQGoPe9uhI%2Fhgjq9TNEfkRk%3D&amp;X-Amz-Signature=acb94d77f38fc4cd62ff3d362e98e2b8f054aa1996a0c4de126debb233fb3814&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22how-rankings-correlate-with-backlink-metrics_cn.png%22"></noscript><p>dofol­low链接数量对谷歌排名的影响要比所有链接数量对谷歌排名的影响要小一些。</p><p>下面是<a href="https://ahrefs.com/tim" target="_blank" rel="noopener">Tim</a>关于这块的观点</p><blockquote class="small"><div class="quote-content"><p>这可能表明谷歌重视优质页中的一些nofollow链接，而会忽略劣质页面的nofollow链接。<strong>但是，谁知道呢？</strong></p></div><div class="quote-info clearfix"><div class="quote-photo"><img class="lazy lazy-hidden" alt="Tim Soulo" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-2.png"><noscript><img alt="Tim Soulo" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-2.png"></noscript></div><div class="extra-box"><span class="quote-author">Tim Soulo,</span> <span class="quote-author-job"><span class="caps">CMO</span> <a href="https://ahrefs.com" target="_blank">Ahrefs</a></span></div></div></blockquote><p>你可以辩证的去看待这个结论。这个研究的主要目的并不是研究nofollow链接和dofollow链接对谷歌排名的影响。我们并没有对这个因素做出定论。</p><p>但即使我们假设nofollow链接对SEO没有直接影响，它们仍然会产生间接影响，因为：</p><h3>1. 它们可以帮助你区分链接</h3><p>自然的外链是多种多样的。</p><p>一些链接是dofollow链接，另外的则是nofollow链接。这个事实是不可避免的，因为有些人不可避免地会通过nofollow链接链接到你…无论你多么希望这样的事情不会发生。</p><p>此外，你从以下地方获得的大多数外链都是nofollow链接:</p><ul><li>社交网络（Facebook，Twitter，YouTube等）</li><li>论坛（Reddit，Quora等）</li><li>新闻发布网站</li><li>留言板</li><li>维基百科（提示：任何人都可以编辑维基百科页面）</li><li>引用链接</li><li>目录网站</li></ul><p>长话短说，如果一个网站只有dofollow链接，或者是占比非常高，那么就非常的可疑了。</p><p>如果你想知道某个页面的dofollow和nofollow链接比例，你可以使用<a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Ahrefs Site Explor­er (网站分析)</a>功能。</p><p><em>Site Explor­er &gt; enter any domain, <span class="caps">URL</span>, or sub­fold­er &gt; Overview</em></p><p><em>网站分析 &gt; 输入域名、<span class="caps">URL</span>、或者目录 &nbsp;&gt; 概览</em></p><p><img class="lazy lazy-hidden wp-image-508" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1.png" alt="pasted image 0 1" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1-768x335.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1-680x297.png 680w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-508" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1.png" alt="pasted image 0 1" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1-768x335.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-1-680x297.png 680w" sizes="(max-width: 900px) 100vw, 900px"></noscript><p>这里可以看到 85%指向Ahrefs的链接（指向域名）是dofollow链接。</p><p>这是好事还是坏事？老实说，只要这里链接有多样性，那就是一个好兆头。</p><p>你不想看到的是100％的dofollow链接，或任何接近100%的数值。因为这就是刻意操作的明确标志。根据经验，我会说60–90％的dofollow链接比例是正常的。当然，这个范围并不是确定的。如果你有疑惑的话，可以深入进行研究。</p><h3>2. 它可以给你提供流量，而流量可以给你提供dofollow的链接机会</h3><p>链接不仅对SEO有用。它们也可以提高引荐流量。</p><p>这就是为什么我们在<a href="https://www.quora.com/" target="_blank" rel="noopener noreferrer">Quo­ra</a>上如此活跃。</p><p>如果你之前没有听说过Quora，没关系。它是一个问答网站，任何人都可以回答人们发布的问题。在这些答案中，Quora允许你链接到相关资源页面。</p><p>下面是我们近期在Quora上的一个回答，有我们的市场管理 <a href="https://twitter.com/itsrbek?lang=en" target="_blank" rel="noopener noreferrer">Rebekah Bek</a>&nbsp;发布，在她的答案中，给了我们博客一个链接。</p><p><img class="lazy lazy-hidden wp-image-511" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/4.png" alt="4" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/4.png 630w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/4-560x425.png 560w" sizes="(max-width: 630px) 100vw, 630px"></p><noscript><img class="wp-image-511" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/4.png" alt="4" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/4.png 630w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/4-560x425.png 560w" sizes="(max-width: 630px) 100vw, 630px"></noscript><p>不幸的是，由于Quora上的所有出站链接都是nofollow链接，不会直接的影响SEO效果。</p><p>一个有意思的地方是：</p><p>如果我们通过<a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Ahrefs Site Explor­er （网站分析）</a>的外链报告观察 Ahrefs.com 的数据，并且通过过滤器功能将dofollow链接筛选出来。我们会发现在众多外链中有这样一个链接。</p><p><img class="lazy lazy-hidden wp-image-527" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16.png" alt="pasted image 0 16" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16-768x132.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16-680x117.png 680w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-527" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16.png" alt="pasted image 0 16" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16-768x132.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-16-680x117.png 680w" sizes="(max-width: 900px) 100vw, 900px"></noscript><p>让我们详细看下这个d­o­fol­low链接是如何来的。</p><p><img class="lazy lazy-hidden wp-image-517" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9.png" alt="pasted image 0 9" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9.png 864w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9-768x635.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9-514x425.png 514w" sizes="(max-width: 864px) 100vw, 864px"></p><noscript><img class="wp-image-517" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9.png" alt="pasted image 0 9" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9.png 864w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9-768x635.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-9-514x425.png 514w" sizes="(max-width: 864px) 100vw, 864px"></noscript><p>我们得到这个<strong>dofol­low链接</strong>的原因是因为这篇文章的作者偶然发现了Rebekah在Quora答案。换句话说，nofollow的链接间接带来了一个dofollow链接。</p><p>所以请记住：想让别人给你链接，有三件事是必需的：</p><ol><li>他们看到你的内容</li><li>他们喜欢你的内容</li><li>他们向其他人推荐（通过他们网站上的链接）</li></ol><p>因为nofollow链接可以帮助完成第一步，所以它们通常是后续产生链接的催化剂。</p><h3>3. Nofollow链接可以防止谷歌惩罚</h3><p>有时候付费链接是有正当的理由的。</p><p>如果一个网站获得了大量的流量，那么在该网站上购买赞助位是完全合理的。如果你为一个赞助位付出了很多钱，那么你可能想要包含一个外链，以便读者可以轻松找到你的网站。</p><p>那么问题来了，谷歌表示，付费的dofollow链接是违反网站站长指南的。</p><p>虽然这么说，但是在SEO中大致分为两个阵营</p><ol><li>一部分人认为，Google<strong>可以</strong>通过算法，准确识别付费链接的人。</li><li>另一部分认为，Google<strong>无法</strong>通过算法，准确识别付费链接的人。</li></ol><p>具体是那个观点正确，我们下次在讨论。</p><p>现在，让我们假设阵营＃2是正确的。谷歌在无法识别任何付费链接行为。这意味着你可以安全地购买和销售链接，对吧？</p><p>别高兴的太早。</p><p>谷歌有一个<a href="https://www.google.com/webmasters/tools/paidlinks" target="_blank" rel="noopener noreferrer">工具</a>，允许任何人举报有网站购买或销售链接的行为。</p><p><img class="lazy lazy-hidden wp-image-526" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/5.png" alt="5"></p><noscript><img class="wp-image-526" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/5.png" alt="5"></noscript><p>解读：你最需要担心的可能并不是谷歌，而是你的竞争对手。</p><p>想想看：如果竞争对手看到你的目标关键字排名很好，并且他们使用像<a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Ahrefs Site Explor­er （网站分析）</a>这样的工具来深入研究你的反向链接之后，就会发现这样的链接结果：</p><p><img class="lazy lazy-hidden wp-image-510" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-3.png" alt="pasted image 0 3"></p><noscript><img class="wp-image-510" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-3.png" alt="pasted image 0 3"></noscript><p>相信你的竞争对手发现后，必然会举报你。</p><p>这样做会导致Google的垃圾网站检测团队检查你的网站，发现付费链接并手动惩罚，那么对于你的对手来说，就少了一个SERP的竞争。</p><p>这就引出了我们下一个主题：</p><div class="post-nav-link clearfix" id="section1"><a class="subhead-anchor" data-tip="tooltip__copielink" rel="#section1 noopener"><svg width="19" height="19" viewBox="0 0 14 14" style><g fill="none" fill-rule="evenodd"><path d="M0 0h14v14H0z" /><path d="M7.45 9.887l-1.62 1.621c-.92.92-2.418.92-3.338 0a2.364 2.364 0 0 1 0-3.339l1.62-1.62-1.273-1.272-1.62 1.62a4.161 4.161 0 1 0 5.885 5.884l1.62-1.62L7.45 9.886zM5.527 5.135L7.17 3.492c.92-.92 2.418-.92 3.339 0 .92.92.92 2.418 0 3.339L8.866 8.473l1.272 1.273 1.644-1.643A4.161 4.161 0 1 0 5.897 2.22L4.254 3.863l1.272 1.272zm-.66 3.998a.749.749 0 0 1 0-1.06l2.208-2.206a.749.749 0 1 1 1.06 1.06L5.928 9.133a.75.75 0 0 1-1.061 0z" style /></g></svg></a><div class="link-text"><h2>如何检测你的网站，并查找与nofollow链接相关的问题</h2></div></div><p>如果你的网站中存在违反谷歌站长规定的链接，是非常有风险的一件事。</p><p>对于你网站上给出的出站链接也是如此，需要nofollow处理。</p><p>但这不仅仅是关于谷歌的惩罚。也可能是某些内部nofollow链接阻碍了SEO效果。以下是快速检查的方法，帮助你识别和消除这类问题。</p><h3>1.检测dofollow外链，并检测其锚文本</h3><p>在大多数情况下，人们在链接到网站时，不会使用完整匹配的锚文本。</p><p>这就是为什么完整匹配的锚文本链接可能意味着外链作弊。</p><p>为了找到这些结果，你可以使用 <a href="https://ahrefs.com/zh/site-explorer" target="_blank">Ahrefs Site Explorer（网站分析）</a>功能。</p><p><em>Site Explor­er &gt; enter your domain &gt; Anchors &gt; dofol­low fil­ter</em></p><p><em>网站分析 &gt; 输入域名 &gt; 锚文本 &gt; 筛选d­o­fol­low链接</em></p><p><img class="lazy lazy-hidden wp-image-522" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12.png" alt="pasted image 0 12" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12-768x399.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12-680x354.png 680w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-522" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12.png" alt="pasted image 0 12" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12-768x399.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-12-680x354.png 680w" sizes="(max-width: 900px) 100vw, 900px"></noscript><p>在这里，我们看到本网站的大部分锚文本都是品牌或通用的词汇（出于隐私目的，我们将一部分结果模糊化了）。但有19个网站（引用域名）使用精准词汇 “pay­day loans”作为锚文本。</p><p>如果我们点击Re­fer­ring Domains（引用域）的数据，我们可以看到这些外链网站具体是什么。</p><p>然后，如果我们再次点击箭头符号，我们可以看到每个外链域的所有外链的上下文情况。</p><p><img class="lazy lazy-hidden wp-image-507" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0.png" alt="pasted image 0" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-768x305.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-680x270.png 680w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-507" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0.png" alt="pasted image 0" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-768x305.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-680x270.png 680w" sizes="(max-width: 900px) 100vw, 900px"></noscript><p>下面是你在处理不同类型链接的一个粗略指南：</p><ul><li><strong>在低质量网站上购买的链接</strong>。你可以要求对方删除（最好）或者nofollow链接。如果他们没有这样做，你可以拒绝这个外链或者整个域名。</li></ul><ul><li><strong>做客博客的个人资料链接</strong>。你之前是否在客座博客的作者介绍中使用了关键词作为锚文本？最好要求该网站的负责人将锚文本换成你的品牌词。或者，如果你希望保留这个锚文本的话，请要求对方负责人把链接换为nofollow链接。</li></ul><ul><li><strong>侧边栏小工具链接</strong>。尝试更改小工具的HTML，将链接换成nofollow链接。</li></ul><ul><li><strong>全站链接</strong>。最好要求对方替换成No­fol­low链接或者替换成品牌次锚文本。</li></ul><p>请注意，完美匹配关键词的链接并不一定示低质量或是付费链接。这可能是在合理的情况下自然发生。</p><p>这就是为什么你需要确保在拒绝这些链接之前，深入调查链接类型或者要求对方nofollow处理。如果你没有做到这一点，有可能是弊大于利的。</p><div class="recommendation"><div class="recommendation-title">专家建议</div><div class="recommendation-content"><p>对于大型网站，锚文本报告中可能有数百或数千个不同的锚文本。</p><p>筛选所有这些数据可能非常耗时。</p><p>下面是一个你可以快速使用的技巧：</p><p>首先，导出dofollow链接的锚文本数据。</p><p>Site Explor­er &gt; enter your domain &gt; Anchors &gt; add “dofol­low” fil­ter &gt; Export &gt; <span class="caps">CSV</span></p><p>网站分析 &gt; 输入域名 &gt; 锚文本 &gt; 添加d­o­fol­low筛选 &gt; 导出 &gt; CSV模式</p><p>将导出的锚文本再次复制进入<a href="https://ahrefs.com/zh/keywords-explorer" target="_blank" rel="noopener">Ahrefs Key­words Explor­er</a>（关键词分析），目前可以支持一次查询10,000个词汇。</p><p>点击查询按钮，并且点击表头的CPC（每次点击费用）一栏，从大到小排列。</p><p><img class="lazy lazy-hidden wp-image-521" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-11.png" alt="pasted image 0 11" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-11.png 665w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-11-260x166.png 260w" sizes="(max-width: 665px) 100vw, 665px"></p><noscript><img class="wp-image-521" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-11.png" alt="pasted image 0 11" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-11.png 665w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-11-260x166.png 260w" sizes="(max-width: 665px) 100vw, 665px"></noscript><p>通常，高CPC（每次点击费用）的锚文本可能是垃圾链接经常使用的。我们可以通过这样的方式找到那些可能会出现垃圾链接的锚文本。</p><p>最后，在Site Explorer（网站分析）的报告中搜索此类型的锚文本，并且检查任何看起来像垃圾链接的资源，并进一步调查。</p><p><img class="lazy lazy-hidden wp-image-520" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10.png" alt="pasted image 0 10" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10.png 830w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10-768x196.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10-680x174.png 680w" sizes="(max-width: 830px) 100vw, 830px"></p><noscript><img class="wp-image-520" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10.png" alt="pasted image 0 10" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10.png 830w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10-768x196.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-10-680x174.png 680w" sizes="(max-width: 830px) 100vw, 830px"></noscript></div></div><h3>2. 寻找Dofollow的付费赞助链接</h3><p>如果你的外链来源于付费赞助的方式，那么这链接最好使用nofollow。</p><p>理由是，你这个链接是购买的，所以最好不然它传递任何的PR值。</p><p>为了找到这样的赞助链接，你可以在<a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Ahrefs Site Explor­er</a>（网站分析）中的<strong>外链报告</strong>中筛选包含 “spon­sored” 字样的链接。</p><p><em>Site Explor­er &gt; Back­links &gt; search for “spon­sored” &gt; fil­ter for “dofol­low”</em></p><p><em>网站分析 &gt; 外链 &gt; 搜索 “spon­sored” &gt; 筛选d­o­fol­low链接</em></p><p><img class="lazy lazy-hidden wp-image-513" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5.png" alt="pasted image 0 5" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5.png 899w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5-768x269.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5-680x238.png 680w" sizes="(max-width: 899px) 100vw, 899px"></p><noscript><img class="wp-image-513" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5.png" alt="pasted image 0 5" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5.png 899w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5-768x269.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-5-680x238.png 680w" sizes="(max-width: 899px) 100vw, 899px"></noscript><p>并且联系对方站长，要求他们把链接设置为nofollow。</p><h3>3. 找到多次出现同一锚文本的出站链接，并nofollow处理</h3><p>你知道吗？2017年福布斯网站的的所有出站链接都设置了nofollow？</p><p>此举原因是，他们注意到他们的一些贡献者在他们的文章中出售dofollow的链接位置。他们有非常多的的贡献者，导致他们也不可能审查网站上的所有链接，所以采取了nofollow所有出站链接的方式。</p><p>这个和你有什么关系呢？</p><p>因为如果你曾经在自己的网站上接受过访客留帖，或者任何用户生成的内容，那么你可能会有相同的感受。</p><p>为了找到这样的出站链接，你最好在 <a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Ahrefs Site Explor­er</a>（网站分析）中检查下你的出战链接锚文本。</p><p><em>Site Explor­er &gt; enter your domain &gt; Out­go­ing links &gt; Anchors &gt; add “dofol­low” fil­ter</em></p><p><em>网站分析 &gt; 输入域名 &gt; 出站链接 &gt; 锚文本 &gt; 筛选d­o­fol­low链接</em></p><p><img class="lazy lazy-hidden wp-image-524" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-14.png" alt="pasted image 0 14"></p><noscript><img class="wp-image-524" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-14.png" alt="pasted image 0 14"></noscript><p>查找一些可疑的单词或短语的锚文本，删除或禁止任何看似有问题的链接（例如，在用户讲简介中出现的锚文本链接，等等）</p><p>至于为什么要这么做，谷歌已经给出了它的<a href="https://support.google.com/webmasters/answer/96569?hl=en" target="_blank" rel="noopener noreferrer">解释</a>：</p><blockquote class="small"><div class="quote-content">如果你无法或不想保证从你的站点链接到的页面内容是优质的（例如，不受信任的用户评论或留言板内容） — 你应该no­fol­low这些链接。<strong>这可以阻止垃圾链接发送者定位你的网站，并有助于防止你的网站无意中将PR值传递到这些不受信任的页面上。</strong></div></blockquote><div class="recommendation"><div class="recommendation-title">你发现了很多锚文本吗?</div><div class="recommendation-content"><p>查看第一步中的专家建议板块吧。</p></div></div><h3>4. 在你的网站中找到dofollow的赞助链接</h3><p>你有没有在你的网站上接受过赞助商的页面？</p><p>你确定没有链接吗？如果你不确定的话，可能需要检查一下。</p><p>为了找到这些页面，你可以在谷歌当中搜索：<code>site:yourwebsite.com "sponsored post"</code></p><p><img class="lazy lazy-hidden wp-image-525" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15.png" alt="pasted image 0 15" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15.png 799w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15-768x207.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15-680x183.png 680w" sizes="(max-width: 799px) 100vw, 799px"></p><noscript><img class="wp-image-525" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15.png" alt="pasted image 0 15" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15.png 799w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15-768x207.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-15-680x183.png 680w" sizes="(max-width: 799px) 100vw, 799px"></noscript><p>按照显示的结果，一个一个检查你的是否存在赞助的链接</p><p>如果你安装过<a href="https://chrome.google.com/webstore/detail/nofollow/dfogidghaigoomjdeacndafapdijmiid?hl=en" target="_blank" rel="noopener noreferrer">Chrome浏览器的no­fol­low插件</a>，页面上的所有nofollow链接都会被高亮标注出来。付费赞助链接如果是nofollow的话会立马被标注出来，如果没有标注，则这个链接就是dofollow链接。</p><p><img class="lazy lazy-hidden wp-image-519" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/6.png" alt="6" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/6.png 715w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/6-680x282.png 680w" sizes="(max-width: 715px) 100vw, 715px"></p><noscript><img class="wp-image-519" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/6.png" alt="6" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/6.png 715w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/6-680x282.png 680w" sizes="(max-width: 715px) 100vw, 715px"></noscript><p>你也可以通过查看HTM­L代码来确认是否做了no­fol­low。</p><p>右击链接，选择查看元素，并寻找 rel=”nofollow”的标注。</p><p><img class="lazy lazy-hidden wp-image-528" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/7.png" alt="7" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/7.png 726w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/7-680x120.png 680w" sizes="(max-width: 726px) 100vw, 726px"></p><noscript><img class="wp-image-528" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/7.png" alt="7" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/7.png 726w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/7-680x120.png 680w" sizes="(max-width: 726px) 100vw, 726px"></noscript><p>如果没有出现这个标注的话，那么就是dofollow链接，你可能需要nofollow处理了。</p><h3>5. 寻找被nofollow的内部链接</h3><p>没有任何一个内链需要被nofollow处理，除非这个链接指向了不重要的页面，或者是这个页面不需要被搜索引擎索引。</p><p>为了找出这些链接，你可以使用 <a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Ahrefs Site Explor­er</a>（网站分析）中的 <strong>最佳链接报告</strong>。</p><p><em>Site Explor­er &gt; enter your domain &gt; Best by Links &gt; switch to Inter­nal &gt; sort by the “nofol­low” col­umn</em></p><p><em>网站分析 &gt; 输入域名 &gt; 最佳链接 &gt; 切换至内链 &gt; 按照no­fol­low链接进行排序</em></p><p><img class="lazy lazy-hidden wp-image-512" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4.png" alt="pasted image 0 4" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4.png 781w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4-768x315.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4-680x279.png 680w" sizes="(max-width: 781px) 100vw, 781px"></p><noscript><img class="wp-image-512" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4.png" alt="pasted image 0 4" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4.png 781w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4-768x315.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-4-680x279.png 680w" sizes="(max-width: 781px) 100vw, 781px"></noscript><p>如果你看到有nofollow内链的页面，请点击该数字，并查看这些链接的来源，做进一步调查。有些情况可能是可以做nofollow的（例如，指向登录页面的nofollow内链）。</p><p>但是，如果没有明确理的nofollow内链，建议你删除nofollow标记。</p><p>下方就是这样的情况。出于某种原因，我们从一个页面到另一个页面的链接就做了nofollow处理。</p><p><img class="lazy lazy-hidden wp-image-514" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6.png" alt="pasted image 0 6" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6-768x245.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6-680x217.png 680w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-514" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6.png" alt="pasted image 0 6" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6-768x245.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-6-680x217.png 680w" sizes="(max-width: 900px) 100vw, 900px"></noscript><div class="recommendation"><div class="recommendation-title">专家建议</div><div class="recommendation-content"><p>如果你想要要更详细地分析网站上的nofollow链接问题，请在<a href="https://ahrefs.com/site-audit" target="_blank" rel="noopener">Ahrefs Site Audit</a>（网站检测）中检测下你的整个站点。</p><p>这不仅可以为你100%的提供最新的数据，还可以提醒你一系列与内部和外部nofollow链接的相关的问题。</p><p><img class="lazy lazy-hidden wp-image-523" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-13.png" alt="pasted image 0 13"></p><noscript><img class="wp-image-523" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-13.png" alt="pasted image 0 13"></noscript><p>上图就是<a href="https://ahrefs.com/zh/site-audit" target="_blank" rel="noopener">Ahrefs Site Audit</a>（网站检测）中显示的nofollow相关问题列表。</p><p>你可以通过<a href="https://www.youtube.com/watch?v=LjinWqfGyVE" target="_blank" rel="noopener noreferrer">这个视频</a>了解，如何在<a href="https://ahrefs.com/zh/site-audit" target="_blank" rel="noopener">Ahrefs Site Audit</a>（网站检测）中做整站检测。</p><div class="arve-wrapper arve-normal-wrapper arve-youtube-wrapper " itemscope itemtype="http://schema.org/VideoObject" style="background-image: url(//img.youtube.com/vi/LjinWqfGyVE/0.jpg);"><div class="arve-embed-container"><iframe id="arve-iframe-2" class="arve-inner arve-hidden" data-src="//www.youtube.com/embed/LjinWqfGyVE?iv_load_policy=3&amp;modestbranding=1&amp;rel=0&amp;wmode=transparent&amp;autoplay=1" frameborder="0" scrolling="no" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe><button class="arve-inner arve-play-background arve-iframe-btn" data-target="arve-iframe-2"></button></div></div><p><a href="https://www.youtube.com/watch?v=LjinWqfGyVE" target="_blank" rel="noopener" class="arve-hidden">https://www.youtube.com/watch?v=LjinWqfGyVE</a></p></div></div><h2>最后总结</h2><p>在SEO当中，nofollow有着很重要的作用。</p><p>希望这篇教程能成功地为你提供所需的知识，让nofollow链接给你帮助.…..而不是阻碍你的优化工作。</p><p>在结束之前，我有一个最终（可能非常明显）的观点：如果你正在进行网站的链接建设，那么优先进行dofollow的链接建设可能是最好的。因为这些链接会传递PR值，并直接影响你网站的SEO效果。</p><p>在我们的<a href="https://ahrefs.com/zh/site-explorer" target="_blank" rel="noopener">Site Explor­er</a>（网站分析）工具中，我们提供了dofollow和nofollow链接的筛选功能。</p><p><img class="lazy lazy-hidden wp-image-531" src="//ahrefs.com/blog/zh/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif" data-lazy-type="image" data-src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18.png" alt="pasted image 0 18" srcset data-srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18-768x214.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18-680x190.png 680w" sizes="(max-width: 900px) 100vw, 900px"></p><noscript><img class="wp-image-531" src="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18.png" alt="pasted image 0 18" srcset="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18.png 900w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18-768x214.png 768w, https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/pasted-image-0-18-680x190.png 680w" sizes="(max-width: 900px) 100vw, 900px"></noscript><p>有了这样的功能，可以给你在<a href="https://ahrefs.com/blog/get-competitors-backlinks/" target="_blank" rel="noopener">研究竞争对手外链</a>时、或者是在进行 ”<a href="https://ahrefs.com/blog/skyscraper-technique/" target="_blank" rel="noopener">sky­scraper</a>” 的操作时，或者是其它的一些情况，能给你带来很多帮助。</p><p>如果你还有问题，可以在下方给我评论，或者直接在<a href="https://twitter.com/joshuachardwick?lang=en" target="_blank" rel="noopener noreferrer">推特中</a>联系我就可以。</p><p><em>译者，Park Cheng，<a href="https://park.mobayke.com/" target="_blank" rel="noopener noreferrer">魔贝课凡</a>联合创始人</em></p> <span itemscope itemtype="http://schema.org/Article" class="itempropwp-wrap"><meta itemprop="name" content="Nofollow链接 VS Follow链接：所有你需要了解的知识"><meta itemprop="headline" content="Nofollow链接 VS Follow链接：所有你需要了解的知识"><meta itemscope itemprop="mainEntityOfPage" itemtype="https://schema.org/WebPage" itemid="https://ahrefs.com/blog/zh/nofollow-links/"><meta itemprop="url" content="https://ahrefs.com/blog/zh/nofollow-links/"><span itemprop="image" itemscope itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://ahrefs.com/blog/zh/wp-content/uploads/2019/07/nofollow-links-facebook-1.jpg"><meta itemprop="width" content="1200"><meta itemprop="height" content="628"></span><meta itemprop="author" content="https://ahrefs.com/blog/zh/author/joshua-hardwick/"><meta itemprop="description" content><meta itemprop="datePublished" content="2019-07-30 12:14:28"><meta itemprop="dateModified" content="2019-11-21 10:03:01"><meta itemprop="interactionCount" content="UserComments:0"><span itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><span itemprop="logo" itemscope itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://cdn.ahrefs.com/images/logo/logo_180x80.jpg"></span><meta itemprop="name" content></span></span> </span></div></div></div></div></div><div id="tooltip__ce__referringDomain" class="hide"><p class="text-xs-left">Shows how many different websites are linking to this piece of content. As a general rule, the more websites link to you, the higher you rank in Google.</p></div><div id="tooltip__ce__searchTraffic" class="hide"><p class="text-xs-left">Shows estimated monthly search traffic to this article according to Ahrefs data. The actual search traffic (as reported in Google Analytics) is usually 3-5 times bigger.</p></div><div id="tooltip__copielink" class="hide"><p class="text-xs-left">Copy link</p></div><footer class="post-footer"><div class="container"><div class="row"><div class="col-lg-12 col-md-12 col-sm-12 col-xs-12"><div class="post-content"><div class="share-post-bottom"><h3>分享</h3><div class="twitter sharrre sharrre-twitter-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Tweet" onclick="ss(0,0,2);"><div class="box"><div class="share"><i class="fa fa-twitter"></i></div></div></div><div class="facebook sharrre sharrre-facebook-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Share" onclick="ss(0,1,2);"><div class="box"><div class="share"><i class="fa fa-facebook"></i></div></div></div><div class="linkedin sharrre sharrre-linkedin-533" data-url="https://ahrefs.com/blog/zh/nofollow-links/" data-text="Nofollow链接 VS Follow链接：所有你需要了解的知识" data-title="Share" onclick="ss(0,2,2);"><div class="box"><div class="share"><i class="fa fa-linkedin"></i></div></div></div></div></div></div></div></div></footer><div class="container"><div class="post-content"><div class="author-meta post-footer"><div class="l"><div class="imageWrapper"><img title="Joshua Hardwick" src="https://ahrefs.com/blog/zh/wp-content/themes/Ahrefs-4/images/authors/JoshuaHardwick.jpg"></div></div><div class="r"><div class="authors"><div class="articleBy"><h4>文章作者:</h4> <a href="https://ahrefs.com/blog/zh/author/joshua-hardwick/" title="Posts by Joshua Hardwick" rel="author"> <span class="fn"><h5>Joshua Hardwick</h5></span> </a></div></div><div class="author-desc" style="min-height:70px;"> Ahrefs内容营销总监。他负责确保我们发布的每篇文章都是神作。The SEO Project创始人。</div><div class="author-social"> <a class="webpage author-link" href="http://www.theseoproject.org/" target="_blank"><span class="glyphicon glyphicon-home"></span></a><a class="twitter" href="https://twitter.com/joshuachardwick" target="_blank"><i class="fa fa-twitter"></i></a></div></div></div></div></div> <script type="text/javascript">function copyStringToClipboard (string) {            function handler (event){                event.clipboardData.setData('text/plain', string);                event.preventDefault();                document.removeEventListener('copy', handler, true);            }            document.addEventListener('copy', handler, true);            document.execCommand('copy');        }        function StartTooltip() {            var option = {                position: $(this).data('position'),                size: 'medium',                maxWidth: 247,                fadeIn: 50            }            if(typeof Tipped != "undefined") {                Tipped.remove($('.ahrefs-icon-info'));                $('.ahrefs-icon-info').each(function () {                    Tipped.create($(this), $("#" + $(this).data('tip')).html(), option);                });                Tipped.remove($('.subhead-anchor'));                $('.subhead-anchor').each(function (item, index) {                    var element = Tipped.create($(this), $("#" + $(this).data('tip')).html(), option);                    var _that = this;                    $(this).click(function(){                        copyStringToClipboard(window.location.href.split('#')[0] + $(this).attr("rel"));                        $(".tpd-content").text("Copied to clipboard");                        Tipped.refresh()                    });                    $(this).on("mouseleave", function(){                        $(".tpd-content").text("Copy link");                        Tipped.refresh()                    })                });            }        }        var ARTICLE_STATES = $(".author-desktop").find(".article-stats");        var ARTICLE_STATES_POSITION = ARTICLE_STATES.offset().top + ARTICLE_STATES.height();        function showHideSharePost(SCROLLTOP) {            if (SCROLLTOP > ARTICLE_STATES_POSITION) {                $('.share-post').addClass('show');            } else {                $('.share-post').removeClass('show');            }        }        $(function () {            StartTooltip();            showHideSharePost($(window).scrollTop());            $(window).scroll(function () {                var SCROLLTOP = $(this).scrollTop();                showHideSharePost(SCROLLTOP);            });        });</script> </div></div></div></div><footer id="footer"><div class="footer-inner"><div class="row"><div class="form-row search-menu-form"><div class="container"><div class="search-menu-form-list-container"><div class="search-menu-form-list-item"><div class="form-inner"><form method="get" id="searchform-main" action="https://ahrefs.com/blog/zh"> <input type="text" class="searching" value="" name="s" placeholder="搜索博客.." /><button type="submit" class="btn-submit search-icon">Search</button></form><div class="languages-picker"><h3 class="links-block-title">Pick a Language</h3><div class="dropdown"> <button class="languages-picker-toggle" id="langaugePicker" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"> 中文 <span class="caret"></span> </button><ul class="dropdown-menu" aria-labelledby="langaugePicker"><li><a href="https://ahrefs.com/blog/" target="_blank" rel="noopener">English</a></li><li><a href="https://ahrefs.com/blog/es/" target="_blank" rel="noopener">Español</a></li><li><a href="https://ahrefs.com/blog/de/" target="_blank" rel="noopener">Deutsch</a></li><li><a href="https://ahrefs.com/blog/ru/" target="_blank" rel="noopener">Русский</a></li><li><a href="https://ahrefs.com/blog/zh/" target="_blank" rel="noopener">中文</a></li><li><a href="https://ahrefs.com/blog/it/" target="_blank" rel="noopener">Italiano</a></li></ul></div></div></div></div><div class="search-menu-form-list-item"><h3 class="links-block-title">主要工具</h3><div class="links-block"><ul class="no-marker"><li> <a href="https://ahrefs.com/site-explorer" target="_blank">Site Explorer</a></li><li> <a href="https://ahrefs.com/keywords-explorer" target="_blank">Keywords Explorer</a></li><li> <a href="https://ahrefs.com/content-explorer" target="_blank">Content Explorer</a></li><li> <a href="https://ahrefs.com/site-audit" target="_blank">Site Audit</a></li><li> <a href="https://ahrefs.com/rank-tracker" target="_blank">Rank Tracker</a></li></ul></div></div><div class="search-menu-form-list-item"><h3 class="links-block-title">其它工具</h3><div class="links-block"><ul class="no-marker"><li> <a href="https://ahrefs.com/backlink-checker" target="_blank">Backlink Checker</a></li><li> <a href="https://ahrefs.com/website-authority-checker" target="_blank">Website Authority Checker</a></li><li> <a href="https://ahrefs.com/keyword-rank-checker" target="_blank">Keyword Rank Checker</a></li><li> <a href="https://ahrefs.com/broken-link-checker" target="_blank">Broken Link Checker</a></li><li> <a href="https://ahrefs.com/serp-checker" target="_blank">SERP Checker</a></li></ul></div></div><div class="search-menu-form-list-item"><h3 class="links-block-title">Ahrefs博客最佳文章</h3><div class="links-block"><ul class="no-marker"><li> <a href="https://ahrefs.com/blog/seo-basics/" target="_blank">SEO Basics (5 Steps)</a></li><li> <a href="https://ahrefs.com/blog/keyword-research/" target="_blank">Keyword Research Guide</a></li><li> <a href="https://ahrefs.com/blog/long-tail-keywords/" target="_blank">Long-Tail Keywords Guide</a></li><li> <a href="https://ahrefs.com/blog/link-building/" target="_blank">Complete Link Building Guide</a></li><li> <a href="https://ahrefs.com/blog/on-page-seo/" target="_blank">On-Page SEO (Actionable Guide)</a></li><li> <a href="https://ahrefs.com/blog/seo-tips/" target="_blank">75 Actionable SEO Tips</a></li><li> <a href="https://ahrefs.com/blog/blogger-outreach/" target="_blank">Blogger Outreach Guide</a></li></ul></div></div></div></div></div></div><div class="row"><div class="container"><div class="col-lg-12 col-md-12 col-sm-12 col-xs-12"><div class="copyright"> &copy; 2019 <a href="/">Ahrefs Pte Ltd.</a></div></div></div></div></div></footer> <script type='text/javascript'>var pollsL10n = {"ajax_url":"https:\/\/ahrefs.com\/blog\/zh\/wp-admin\/admin-ajax.php","text_wait":"Your last request is still being processed. Please wait a while ...","text_valid":"Please choose a valid poll answer.","text_multiple":"Maximum number of choices allowed: ","show_loading":"1","show_fading":"1"};</script> <script type='text/javascript'>var a3_lazyload_params = {"apply_images":"1","apply_videos":"1"};</script> <script type='text/javascript'>var a3_lazyload_extend_params = {"edgeY":"0"};</script>  <script>/*!    * IE10 viewport hack for Surface/desktop Windows 8 bug    * Copyright 2014 Twitter, Inc.    * Licensed under the Creative Commons Attribution 3.0 Unported License. For    * details, see http://creativecommons.org/licenses/by/3.0/.    */    // See the Getting Started docs for more information:    // http://getbootstrap.com/getting-started/#support-ie10-width    (function () {        'use strict';        if (navigator.userAgent.match(/IEMobile\/10\.0/)) {        var msViewportStyle = document.createElement('style')        msViewportStyle.appendChild(          document.createTextNode(            '@-ms-viewport{width:auto!important}'          )        )        document.querySelector('head').appendChild(msViewportStyle)        }    })();</script> <script type="text/javascript" defer src="https://ahrefs.com/blog/zh/wp-content/cache/autoptimize/js/autoptimize_1464552d3e187d4793f4d9316166b59f.js"></script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        
&lt;!DOCTYPE html &gt; &lt;!--[if !IE]&gt;&lt;html class=&quot;no-js non-ie&quot; lang=&quot;zh-Hans&quot;&gt; &lt;![endif]--&gt; &lt;!--[if IE 7 ]&gt;&lt;html class=&quot;no-js ie7&quot; lang=&quot;zh-Hans&quot;
      
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="SEO" scheme="http://yoursite.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>实现tornado login_required()</title>
    <link href="http://yoursite.com/2019/08/01/tornado-login-required/"/>
    <id>http://yoursite.com/2019/08/01/tornado-login-required/</id>
    <published>2019-08-01T06:20:20.000Z</published>
    <updated>2019-11-04T17:15:57.581Z</updated>
    
    <content type="html"><![CDATA[<p>tornado作为鼎鼎大名的web异步框架，用来作为高性能服务器以及web框架都是首选。自从python3.4加入了asyncio原生协程后，tornado的最新版本也开始使用了原生的协程。定义协程函数的时候就很简单了，也可以像sanic一样使用async def了。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LoginHandler(RequestHandler):</span><br><span class="line">    async def post(self, *args, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>一般的web项目都会有登陆的功能，这就涉及到了登陆验证，在做这一部分功能的时候，我使用的是 jwt – json web token的方法验证是否登陆。当然也可以使用类似于django的session验证。各自均有优缺点。</p><p>通常需要验证是否登陆的模块很多，一般都会写一个登陆验证装饰器，tornado实现了登陆验证装饰器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def authenticated(method):</span><br><span class="line">    &quot;&quot;&quot;Decorate methods with this to require that the user be logged in.</span><br><span class="line"></span><br><span class="line">    If the user is not logged in, they will be redirected to the configured</span><br><span class="line">    `login url &lt;RequestHandler.get_login_url&gt;`.</span><br><span class="line"></span><br><span class="line">    If you configure a login url with a query parameter, Tornado will</span><br><span class="line">    assume you know what you&apos;re doing and use it as-is.  If not, it</span><br><span class="line">    will add a `next` parameter so the login page knows where to send</span><br><span class="line">    you once you&apos;re logged in.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @functools.wraps(method)</span><br><span class="line">    def wrapper(self, *args, **kwargs):</span><br><span class="line">        if not self.current_user:</span><br><span class="line">            if self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;):</span><br><span class="line">                url = self.get_login_url()</span><br><span class="line">                if &quot;?&quot; not in url:</span><br><span class="line">                    if urlparse.urlsplit(url).scheme:</span><br><span class="line">                        # if login url is absolute, make next absolute too</span><br><span class="line">                        next_url = self.request.full_url()</span><br><span class="line">                    else:</span><br><span class="line">                        next_url = self.request.uri</span><br><span class="line">                    url += &quot;?&quot; + urlencode(dict(next=next_url))</span><br><span class="line">                self.redirect(url)</span><br><span class="line">                return</span><br><span class="line">            raise HTTPError(403)</span><br><span class="line">        return method(self, *args, **kwargs)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>method(self,<em>args,*</em>kwargs)即为要装饰的函数。但是如果 像上面定义的post方法 async def post(self, <em>args, *</em>kwargs),作为一个协程函数，就不能再使用这个装饰器了，就需要改写一下这个装饰器。def authenticated_async(method):</p><p>初始化app的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import tornado</span><br><span class="line">from peewee_async import Manager</span><br><span class="line"></span><br><span class="line">from YourApp.urls import urlpattern</span><br><span class="line">from YourApp.settings import settings, database</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    #集成json到wtforms</span><br><span class="line">    import wtforms_json</span><br><span class="line">    wtforms_json.init()</span><br><span class="line"></span><br><span class="line">    app = web.Application(urlpattern, debug=True, **settings)</span><br><span class="line">    app.listen(80)</span><br><span class="line"></span><br><span class="line">    objects = Manager(database)</span><br><span class="line">    database.set_allow_sync(False)</span><br><span class="line">    app.objects = objects</span><br><span class="line"></span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>登陆装饰器改写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@functools.wraps(method)</span><br><span class="line">async def wrapper(self, *args, **kwargs):</span><br><span class="line">    tsessionid = self.request.headers.get(&quot;tsessionid&quot;, None)</span><br><span class="line">    if tsessionid:</span><br><span class="line">        try:</span><br><span class="line"></span><br><span class="line">            send_data = jwt.decode(tsessionid, self.settings[&quot;secret_key&quot;], leeway=self.settings[&quot;jwt_expire&quot;], options=&#123;&quot;verify_exp&quot;: True&#125;)</span><br><span class="line">            user_id = send_data[&quot;id&quot;]</span><br><span class="line">            # User 的model类，根据实际情况调整</span><br><span class="line">            #从数据库中获取到user并设置给_current_user</span><br><span class="line">            try:</span><br><span class="line">                user = await self.application.objects.get(User, id=user_id)</span><br><span class="line">                self._current_user = user</span><br><span class="line"></span><br><span class="line">                # 协程的调用方式</span><br><span class="line">                await method(self, *args, **kwargs)</span><br><span class="line">            except User.DoesNotExist as e:</span><br><span class="line">                self.set_status(401)</span><br><span class="line">        except jwt.ExpiredSignatureError as e: # 验证jwt 是否过期</span><br><span class="line">            self.set_status(401)</span><br><span class="line">    else:</span><br><span class="line">        self.set_status(401)</span><br><span class="line">    self.finish(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">return wrapper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado作为鼎鼎大名的web异步框架，用来作为高性能服务器以及web框架都是首选。自从python3.4加入了asyncio原生协程后，tornado的最新版本也开始使用了原生的协程。定义协程函数的时候就很简单了，也可以像sanic一样使用async def了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="后端" scheme="http://yoursite.com/categories/python/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocks源码解读</title>
    <link href="http://yoursite.com/2019/07/20/shadowsockts%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/07/20/shadowsockts源码解读/</id>
    <published>2019-07-20T04:00:40.000Z</published>
    <updated>2019-11-04T17:15:57.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shadowsocks源码解读"><a href="#shadowsocks源码解读" class="headerlink" title="shadowsocks源码解读"></a>shadowsocks源码解读</h2><p>经常使用shadowsocks科学上网，但是一直没有时间去看一看人家怎么写的。<br>先记录一下一篇写的很详细的博客，这篇就当书签用啦。<br><a href="https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html" target="_blank" rel="noopener">Shadowsocks 源码分析——协议与结构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;shadowsocks源码解读&quot;&gt;&lt;a href=&quot;#shadowsocks源码解读&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks源码解读&quot;&gt;&lt;/a&gt;shadowsocks源码解读&lt;/h2&gt;&lt;p&gt;经常使用shadowsocks科学上
      
    
    </summary>
    
    
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>queue.Queue 和mutiprocessing.Queue</title>
    <link href="http://yoursite.com/2019/06/17/queue-Queue%20and%20multiprocessing-Queue/"/>
    <id>http://yoursite.com/2019/06/17/queue-Queue and multiprocessing-Queue/</id>
    <published>2019-06-17T03:09:40.000Z</published>
    <updated>2019-11-04T17:18:24.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这两个队列到底有什么不一样，又分别能在什么场景下使用呢"><a href="#这两个队列到底有什么不一样，又分别能在什么场景下使用呢" class="headerlink" title="这两个队列到底有什么不一样，又分别能在什么场景下使用呢?"></a>这两个队列到底有什么不一样，又分别能在什么场景下使用呢?</h2><p>queue.Queue只是一个内存队列，在多线程下使用。如果错误得用在了多进程中，那么每个进程都会创建一个Queue的实例,<br>因为进程不再共享<a id="more"></a>相同的内存。<br>也就是仅当生产者和消费者处于同一进程中时，这个Queue才能达到预期的效果。<br>看一下queue.Queue的初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, maxsize=0):</span><br><span class="line">    self.maxsize = maxsize</span><br><span class="line">    self._init(maxsize)</span><br><span class="line"></span><br><span class="line">    # mutex must be held whenever the queue is mutating.  All methods</span><br><span class="line">    # that acquire mutex must release it before returning.  mutex</span><br><span class="line">    # is shared between the three conditions, so acquiring and</span><br><span class="line">    # releasing the conditions also acquires and releases mutex.</span><br><span class="line">    self.mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line">    # Notify not_empty whenever an item is added to the queue; a</span><br><span class="line">    # thread waiting to get is notified then.</span><br><span class="line">    self.not_empty = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    # Notify not_full whenever an item is removed from the queue;</span><br><span class="line">    # a thread waiting to put is notified then.</span><br><span class="line">    self.not_full = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    # Notify all_tasks_done whenever the number of unfinished tasks</span><br><span class="line">    # drops to zero; thread waiting to join() is notified to resume</span><br><span class="line">    self.all_tasks_done = threading.Condition(self.mutex)</span><br><span class="line">    self.unfinished_tasks = 0</span><br></pre></td></tr></table></figure><p>在多进程应用场景中，如果多个进程需要共享数据，那么就不能使用queue.Queue了。<br>而应该使用可以共享内存的管道或套接字，也可以是其他东西-multiprocessing.Queue。它使用管道为两个进程进行通信提供一种方式。而这两个Queue又<br>恰好实现了与相同的API，因为大多数Python程序员已经非常熟悉它。</p><p>下面一段代码在Windows环境下会报错 <code>TypeError: can&#39;t pickle _thread.lock objects</code>：<br>进程池内部处理使用了pickle模块用于python特有的类型和python的数据类型间进行转换。<br>pickle模块要对内部的成员变量进行序列化，但不支持对自定义对象加锁，所以会抛出类型异常的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool, Process,Queue,JoinableQueue</span><br><span class="line">import os, time</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">def write(q): </span><br><span class="line">    for v in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: </span><br><span class="line">        print(&apos;Put %s to queue &apos; % v)</span><br><span class="line">        q.put_nowait(v) </span><br><span class="line">        time.sleep(0.2) </span><br><span class="line"></span><br><span class="line">def read(q): </span><br><span class="line">    while 1: </span><br><span class="line">        if not q.empty(): </span><br><span class="line">            v = q.get(True) </span><br><span class="line">            print(&quot;Get %s from queue&quot; % v)</span><br><span class="line">            time.sleep(0.2) </span><br><span class="line">        else: </span><br><span class="line">            break </span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;: </span><br><span class="line">    q = Queue() </span><br><span class="line">    pw = Process(target=write, args=(q, )) </span><br><span class="line">    pr = Process(target=read, args=(q, )) </span><br><span class="line">    pw.start() </span><br><span class="line">    pw.join() </span><br><span class="line"></span><br><span class="line">    pr.start() </span><br><span class="line">    pr.join() </span><br><span class="line"></span><br><span class="line">    print(&quot;all done...&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这两个队列到底有什么不一样，又分别能在什么场景下使用呢&quot;&gt;&lt;a href=&quot;#这两个队列到底有什么不一样，又分别能在什么场景下使用呢&quot; class=&quot;headerlink&quot; title=&quot;这两个队列到底有什么不一样，又分别能在什么场景下使用呢?&quot;&gt;&lt;/a&gt;这两个队列到底有什么不一样，又分别能在什么场景下使用呢?&lt;/h2&gt;&lt;p&gt;queue.Queue只是一个内存队列，在多线程下使用。如果错误得用在了多进程中，那么每个进程都会创建一个Queue的实例,&lt;br&gt;因为进程不再共享
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
