<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHERPA-ZARIC</title>
  
  <subtitle>在神秘的珠穆朗玛峰，有一个为世界各国登山队充当向导与挑夫的族群——夏尔巴人 （SHERPA）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-04T17:15:57.589Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZARIC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang一些有用的小技巧</title>
    <link href="http://yoursite.com/2019/11/02/golang%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/11/02/golang小技巧/</id>
    <published>2019-11-02T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化一个定时器"><a href="#初始化一个定时器" class="headerlink" title="初始化一个定时器"></a>初始化一个定时器</h2><p><a href="https://www.kancloud.cn/digest/batu-go/153534" target="_blank" rel="noopener">来源链接</a></p><p><code>ticker := time.NewTimer(2 * time.Second)</code><br>这样就初始化了一个2秒的定时器</p><p>再看一个实际的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    //初始化定时器</span><br><span class="line">    t := time.NewTimer(2 * time.Second)</span><br><span class="line">    //当前时间</span><br><span class="line">    now := time.Now()</span><br><span class="line">    fmt.Printf(&quot;Now time : %v.\n&quot;, now)</span><br><span class="line"></span><br><span class="line">    expire := &lt;- t.C</span><br><span class="line">    fmt.Printf(&quot;Expiration time: %v.\n&quot;, expire)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以time包的NewTimer可以应用在一些调度任务中</p><p>再看一下复杂点的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    //初始化通道</span><br><span class="line">    ch11 := make(chan int, 1000)</span><br><span class="line">    sign := make(chan byte, 1)</span><br><span class="line"></span><br><span class="line">    //给ch11通道写入数据</span><br><span class="line">    for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">        ch11 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单独起一个Goroutine执行select</span><br><span class="line">    go func()&#123;</span><br><span class="line">        var e int</span><br><span class="line">        ok := true</span><br><span class="line">        //首先声明一个*time.Timer类型的值，然后在相关case之后声明的匿名函数中尽可能的复用它</span><br><span class="line">        var timer *time.Timer</span><br><span class="line"></span><br><span class="line">        for&#123;</span><br><span class="line">            select &#123;</span><br><span class="line">                case e = &lt;- ch11:</span><br><span class="line">                    fmt.Printf(&quot;ch11 -&gt; %d\n&quot;,e)</span><br><span class="line">                case &lt;- func() &lt;-chan time.Time &#123;</span><br><span class="line">                    if timer == nil&#123;</span><br><span class="line">                        //初始化到期时间据此间隔1ms的定时器</span><br><span class="line">                        timer = time.NewTimer(time.Millisecond)</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        //复用，通过Reset方法重置定时器</span><br><span class="line">                        timer.Reset(time.Millisecond)</span><br><span class="line">                    &#125;</span><br><span class="line">                    //得知定时器到期事件来临时，返回结果</span><br><span class="line">                    return timer.C</span><br><span class="line">                &#125;():</span><br><span class="line">                    fmt.Println(&quot;Timeout.&quot;)</span><br><span class="line">                    ok = false</span><br><span class="line">                    break</span><br><span class="line">            &#125;</span><br><span class="line">            //终止for循环</span><br><span class="line">            if !ok &#123;</span><br><span class="line">                sign &lt;- 0</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    //惯用手法，读取sign通道数据，为了等待select的Goroutine执行。</span><br><span class="line">    &lt;- sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="time-After函数"><a href="#time-After函数" class="headerlink" title="time.After函数"></a>time.After函数</h2><p>time.After函数</p><ul><li><p>表示多少时间之后，但是在取出channel内容之前不阻塞，后续程序可以继续执行</p></li><li><p>鉴于After特性，其通常用来处理程序超时问题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    ch1 := make(chan int, 1)</span><br><span class="line">    ch2 := make(chan int, 1)</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">        case e1 := &lt;-ch1:</span><br><span class="line">        //如果ch1通道成功读取数据，则执行该case处理语句</span><br><span class="line">            fmt.Printf(&quot;1th case is selected. e1=%v&quot;,e1)</span><br><span class="line">        case e2 := &lt;-ch2:</span><br><span class="line">        //如果ch2通道成功读取数据，则执行该case处理语句</span><br><span class="line">            fmt.Printf(&quot;2th case is selected. e2=%v&quot;,e2)</span><br><span class="line">        case &lt;- time.After(2 * time.Second):</span><br><span class="line">            fmt.Println(&quot;Timed out&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="golang打印结构体"><a href="#golang打印结构体" class="headerlink" title="golang打印结构体"></a>golang打印结构体</h3><p>如果使用fmt.println（v）<br>打印的结果往往令人迷惑，要想看到结构体内部的数据可以使用<br><code>fmt.printf(&quot;+v&quot;,v)</code></p><p><strong>如果需要打印的内容是一个<code>[]</code>byte</strong></p><p>那么使用 fmt.printf(“%s”,v)<br>就可以把这个切片字节的字符串打印出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初始化一个定时器&quot;&gt;&lt;a href=&quot;#初始化一个定时器&quot; class=&quot;headerlink&quot; title=&quot;初始化一个定时器&quot;&gt;&lt;/a&gt;初始化一个定时器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/digest/batu-g
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="golang" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/golang/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>docker file中使用多个FROM</title>
    <link href="http://yoursite.com/2019/10/20/docker-multi-from/"/>
    <id>http://yoursite.com/2019/10/20/docker-multi-from/</id>
    <published>2019-10-20T09:17:18.000Z</published>
    <updated>2019-11-03T13:12:48.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="能否使用多个FROM"><a href="#能否使用多个FROM" class="headerlink" title="能否使用多个FROM?"></a>能否使用多个FROM?</h2><p>在使用docker过程中，dockerhub上的docker镜像往往已经能够满足需求，<br>然鹅，需求是无止境的。有时候我们需要特殊定制一些镜像。我们需要A镜像中的一些文件,以及B镜像中的另外一些文件，以及….</p><a id="more"></a><h2 id="多个-FROM-指令的意义"><a href="#多个-FROM-指令的意义" class="headerlink" title="多个 FROM 指令的意义"></a>多个 FROM 指令的意义</h2><p>多个 FROM 指令并不是为了生成多根的层关系，最后生成的镜像，仍以最后一条 FROM 为准，之前的 FROM 会被抛弃，那么之前的FROM 又有什么意义呢？</p><p>每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。</p><h2 id="构造器模式是什么？"><a href="#构造器模式是什么？" class="headerlink" title="构造器模式是什么？"></a>构造器模式是什么？</h2><p>对于像Golang这样的静态编译语言，人们倾向于从Golang“ SDK”映像中获取其Dockerfile，添加源代码，进行构建，然后将其推送到Docker Hub。但是生成的镜像的大小至少为670M。</p><p>一种非官方的构造器模式(<strong>builder pattern</strong>) 的解决方法是使用两个Docker映像-一个用于执行构建，另一个用于发送第一个构建的结果，而不会破坏第一个映像中的构建链和工具。<br>Golang并不是唯一可以通过使用一个基础映像来构建资产并使用第二个映像来运行资产而受益的语言。<br>在Windows容器中的工作也使用此模式来生成较小的图像。</p><p>builder pattern的示例：</p><ol><li>从Golang基本映像派生整个运行时/ SDK（Dockerfile.build）</li><li>添加源代码</li><li>产生一个静态链接的二进制文件</li><li>将静态二进制文件从镜像复制到主机（docker create，docker cp）</li><li>从<code>SCRATCH</code>或其他轻量级映像分离，例如<code>alpine</code>（Dockerfile）</li><li>重新添加二进制文件</li><li>将这个很小的映像推送到Docker Hub</li></ol><p>这意味着要有两个单独的Dockerfile和一个Shell脚本来编排以上所有7个步骤。</p><p>以一个golang的项目为例：</p><p>Dockerfile.build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>build.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo Building alexellis2/href-counter:build</span><br><span class="line"></span><br><span class="line">docker build --build-arg https_proxy=$https_proxy --build-arg http_proxy=$http_proxy \</span><br><span class="line">    -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract alexellis2/href-counter:build </span><br><span class="line">docker cp extract:/go/src/github.com/alexellis/href-counter/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building alexellis2/href-counter:latest</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><h2 id="什么是多阶段构建？"><a href="#什么是多阶段构建？" class="headerlink" title="什么是多阶段构建？"></a>什么是多阶段构建？</h2><p>多阶段构建具有构建器模式的优点，而无需维护三个单独的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>但是，对于开发者和维护者来说，这仍然很大，特别是使用树莓派的用户。<br>在Dockerfile中使用多个FROM-以最后一条FROM语句为最终基础映像为准<br>。要复制中间图像的伪像和输出，<br>请使用<code>COPY --from=镜像号码</code></p><p>改进后的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>有些程序要么没有apt源，要么apt源中的版本太老，<br>要么干脆只提供源码需要自己编译，使用这些程序时，<br>我们可以方便地使用已经存在的Docker镜像源作为我们的基础镜像。<br>但是我们的软件有时候可能需要依赖多个这种文件，<br>我们并不能同时将 nginx 和 etcd 的镜像同时作为我们的基础镜像<br>（不支持多根），这种情况下，使用 COPY –from 就非常方便实用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;能否使用多个FROM&quot;&gt;&lt;a href=&quot;#能否使用多个FROM&quot; class=&quot;headerlink&quot; title=&quot;能否使用多个FROM?&quot;&gt;&lt;/a&gt;能否使用多个FROM?&lt;/h2&gt;&lt;p&gt;在使用docker过程中，dockerhub上的docker镜像往往已经能够满足需求，&lt;br&gt;然鹅，需求是无止境的。有时候我们需要特殊定制一些镜像。我们需要A镜像中的一些文件,以及B镜像中的另外一些文件，以及….&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>moviepy 中文镜像</title>
    <link href="http://yoursite.com/2019/10/20/moviepy-docker/"/>
    <id>http://yoursite.com/2019/10/20/moviepy-docker/</id>
    <published>2019-10-20T09:17:18.000Z</published>
    <updated>2019-11-04T17:15:57.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先是系统的环境问题。"><a href="#首先是系统的环境问题。" class="headerlink" title="首先是系统的环境问题。"></a>首先是系统的环境问题。</h2><p>linux 安装 moviepy需要很多依赖，安装起来费神费力。配置起来也非常麻烦，最简单的办法是直接使用他人构建好的镜像文件。</p><a id="more"></a><h2 id="再就是字体显示问题。"><a href="#再就是字体显示问题。" class="headerlink" title="再就是字体显示问题。"></a>再就是字体显示问题。</h2><p>镜像中的imagmagick不支持中文的字体。生成的视频中文乱码，搜索了好!</p><p>长时间，决定自己手动构建一个镜像。参考的文章链接：</p><p><a href="https://www.cnblogs.com/dunkbird/p/5623209.html" target="_blank" rel="noopener">linux追加中文字库，解决imagemagick 中文乱码的问题</a></p><p><a href="https://blog.csdn.net/soulmate_P/article/details/8785642" target="_blank" rel="noopener">Linux(Ubuntu，Cent OS)环境安装mkfontscale mkfontdir命令以及中文字库</a></p><p>步骤简单分为几步：</p><ul><li>拷贝本地Windows下的font（选择你想要的）到镜像中。</li><li>镜像安装构建字体的依赖</li><li>构建字体文件夹</li><li>build 镜像</li></ul><p>放一下Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM dkarchmervue/moviepy:latest</span><br><span class="line"># 我在同级目录下创建了一个windows_fonts文件夹，里面放着从window下拷贝过来的文件。考本到镜像的字体文件夹下。</span><br><span class="line">COPY ./wondow_fonts/ /usr/share/fonts/windows/</span><br><span class="line"># 更改ubuntu镜像源，dkarchmervue/moviepy是基于ubuntu14.04，找一个镜像源，在本地创建一个sources.list的文件，拷贝到镜像中就可以。</span><br><span class="line">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">COPY sources.list /etc/apt/sources.list </span><br><span class="line">RUN apt-get update</span><br><span class="line"># 安装添加字体的依赖</span><br><span class="line">RUN apt-get install ttf-mscorefonts-installer -y &amp;&amp; apt-get install fontconfig -y\</span><br><span class="line">     &amp;&amp; apt-get install fontconfig \</span><br><span class="line">    &amp;&amp; cd /usr/share/fonts/windows/ &amp;&amp; chmod 777 * &amp;&amp; mkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache</span><br><span class="line">WORKDIR /work/</span><br></pre></td></tr></table></figure><p>这样就制作了一个基于<code>dkarchmervue/moviepy</code> 的带中文字体的镜像。<br>然后直接运行 <code>docker build -t moviepy_cnfonts .</code> 即可创建一个名为 moviepy_cnfonts的镜像。可以把这个镜像替代<code>dkarchmervue/moviepy:latest</code>这个镜像作为运行 python文件的基础镜像。</p><p>运行moviepy官方的结尾特效 end_effect</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1200357-20190919202017204-216254823.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;首先是系统的环境问题。&quot;&gt;&lt;a href=&quot;#首先是系统的环境问题。&quot; class=&quot;headerlink&quot; title=&quot;首先是系统的环境问题。&quot;&gt;&lt;/a&gt;首先是系统的环境问题。&lt;/h2&gt;&lt;p&gt;linux 安装 moviepy需要很多依赖，安装起来费神费力。配置起来也非常麻烦，最简单的办法是直接使用他人构建好的镜像文件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="moviepy" scheme="http://yoursite.com/tags/moviepy/"/>
    
  </entry>
  
  <entry>
    <title>python-cache</title>
    <link href="http://yoursite.com/2019/10/03/python-cache/"/>
    <id>http://yoursite.com/2019/10/03/python-cache/</id>
    <published>2019-10-03T04:42:40.000Z</published>
    <updated>2019-11-04T17:15:57.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msgpack介绍"><a href="#msgpack介绍" class="headerlink" title="msgpack介绍"></a>msgpack介绍</h2><p>在阅读sanic相关项目的时候 <a href=""https://github.com/howie6879/Sanic-For-Pythoneer/blob/master/docs/part1/6.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7.md"">Sanic-For-Pythoneer</a> 阅读代码过程中发现几个比较好用的python库，</p><h3 id="1-cached"><a href="#1-cached" class="headerlink" title="1. cached"></a>1. cached</h3><p>缓存其实应用场景还是比较多的。比如我现在应用的就是对 从database中获取到的数据做缓存，设置ttl(time to live)以减小数据库压力。</p><a id="more"></a><p>cached的简单应用 （python = 3.7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import aiocache</span><br><span class="line">from aiocache.serializers import NullSerializer, StringSerializer, \</span><br><span class="line">    PickleSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@aiocache.cached(ttl=10, serializer=PickleSerializer())</span><br><span class="line">async def get_res():</span><br><span class="line">    print(&quot;get_res(): int(11)&quot;)</span><br><span class="line">    return 11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import asyncio</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    data = asyncio.run(get_res())</span><br><span class="line">    print(type(data), data)</span><br><span class="line">    data = asyncio.run(get_res())</span><br><span class="line">    print(type(data), data)</span><br></pre></td></tr></table></figure><p>aiocache实现并不复杂。介绍一下 SimpleMemoryCache。大致的思路就是 把数据保存到字典中，key默认为 model_name+ func_name + args + kwargs 组合（可以指定key的值），到了ttl设定的时间就把map中的键值pop出去。<br>其他的也是类似的思路。</p><p>这里值得注意的是 <code>serializer</code>这个参数。如果是使用 <code>SimpleMemoryCache</code>作为缓存，默认是使用 <code>NullSerializer</code>作为序列化工具的，即set的任何内容都可以在get时原样获取，在本地内存中这一点问题没有。<br>如果需要对对象序列化 建议使用 <code>PickleSerializer</code><br><a href=""https://www.zhihu.com/question/38355589"">我是pickle</a></p><p>但是如果使用redis作为缓存，会发生一些预测不到的错误。解决办法是使用：<code>JsonSerializer</code>,内部使用的是 <code>ujson</code>作为序列化工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json module and ujson:</span><br><span class="line">        - ujson dumps supports bytes while json doesn&apos;t</span><br><span class="line">        - ujson and json outputs may differ sometimes</span><br></pre></td></tr></table></figure><p>还有一个 <code>MsgPackSerializer</code>,</p><p><code>Transform data to bytes using msgpack.dumps and msgpack.loads to retrieve it back.</code></p><p>还有一个序列化参数，用的比较少，<code>StringSerializer</code>,比如你缓存的是 1，在下次获取缓存结果的时候会给你返回 <code>&#39;1&#39;</code>。</p><h3 id="2-msgpack"><a href="#2-msgpack" class="headerlink" title="2. msgpack"></a>2. msgpack</h3><p>msgpack 是cached包安装时候的依赖。进入源码，发现其对外提供的API非常简单，用法与 ujson,json 等序列/反序列工具基本一直。</p><p>其源码中对外暴露方法做了常规化处理，这样我们用起来很快适应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># alias for compatibility to simplejson/marshal/pickle.</span><br><span class="line">load = unpack</span><br><span class="line">loads = unpackb</span><br><span class="line"></span><br><span class="line">dump = pack</span><br><span class="line">dumps = packb</span><br></pre></td></tr></table></figure><p>msgpack的优势是：msgpack用起来像json，但是却比json快，并且序列化以后的数据长度更小，言外之意，使用msgpack不仅序列化和反序列化的速度快，数据传输量也比json格式小，msgpack同样支持多种语言。</p><p>我们平时主要会用到 <code>loads</code> 等同于 <code>unpackb</code> , <code>dumps</code> 等同于 <code>packb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import msgpack</span><br><span class="line">&gt;&gt;&gt;animal = &#123;&quot;color&quot;:&quot;pink&quot;,&quot;name&quot;:&quot;duck&quot;&#125;</span><br><span class="line">&gt;&gt;&gt;msgpack.dumps(animal) // 比 json.dumps(x)的长度更小</span><br><span class="line">b&apos;\x82\xa5color\xa4pink\xa4name\xa4duck&apos;</span><br><span class="line">&gt;&gt;&gt;msgpack.loads(msgpack.dumps(animal))</span><br><span class="line">&#123;b&apos;color&apos;: b&apos;pink&apos;, b&apos;name&apos;: b&apos;duck&apos;&#125;</span><br><span class="line">&gt;&gt;&gt;msgpack.loads(msgpack.dumps(animal),encoding=&quot;utf-8&quot;) // 转会初始状态的字符串，需要加上 encoding这个参数，内部会调用decode()方法</span><br><span class="line">&#123;&apos;color&apos;: &apos;pink&apos;, &apos;name&apos;: &apos;duck&apos;&#125;</span><br></pre></td></tr></table></figure><p>另外 load 和 dump的用法和json.load &amp; json.dump用法相同。<br>该包源码非常简单，有兴趣的可以去看看源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;msgpack介绍&quot;&gt;&lt;a href=&quot;#msgpack介绍&quot; class=&quot;headerlink&quot; title=&quot;msgpack介绍&quot;&gt;&lt;/a&gt;msgpack介绍&lt;/h2&gt;&lt;p&gt;在阅读sanic相关项目的时候 &lt;a href=&quot;&quot;https://github.com/howie6879/Sanic-For-Pythoneer/blob/master/docs/part1/6.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7.md&quot;&quot;&gt;Sanic-For-Pythoneer&lt;/a&gt; 阅读代码过程中发现几个比较好用的python库，&lt;/p&gt;
&lt;h3 id=&quot;1-cached&quot;&gt;&lt;a href=&quot;#1-cached&quot; class=&quot;headerlink&quot; title=&quot;1. cached&quot;&gt;&lt;/a&gt;1. cached&lt;/h3&gt;&lt;p&gt;缓存其实应用场景还是比较多的。比如我现在应用的就是对 从database中获取到的数据做缓存，设置ttl(time to live)以减小数据库压力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>flask.run()不是你的服务器！</title>
    <link href="http://yoursite.com/2019/09/23/flask-is-not-production-server/"/>
    <id>http://yoursite.com/2019/09/23/flask-is-not-production-server/</id>
    <published>2019-09-23T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不要再用flask-run-部署项目了！"><a href="#不要再用flask-run-部署项目了！" class="headerlink" title="不要再用flask.run()部署项目了！"></a>不要再用flask.run()部署项目了！</h3><p>在维护公司老项目,服务器查看运行着一个flask项目。用简单的单进程跑在机器上。<br>查看详细的信息，发现是直接用这种方式运行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def route1():</span><br><span class="line">   pass</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(....)</span><br></pre></td></tr></table></figure><a id="more"></a><dl><dt>这种方式真的很不好，稍微看一下docs就能看到flask已经给了很明显的警高信息</dt><dd><code>WARNING: This is a development server. Do not use it in a production deployment.</code></dd></dl><h3 id="下面就来讲一讲为何不好-："><a href="#下面就来讲一讲为何不好-：" class="headerlink" title="下面就来讲一讲为何不好 ："></a><strong>下面就来讲一讲为何不好</strong> ：</h3><p>你已经构建了Flask网络应用，并正在部署自己选择的VPS上。这是你的第一个小型应用程序，你希望将app.run上的debug设置为False就足够了？也许也启用线程？</p><p>你真的不应该依赖于此。官方文档也不同意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">While lightweight and easy to use, Flask’s built-in server is </span><br><span class="line">not suitable for production as it doesn’t scale well </span><br><span class="line">and by default serves only one request at a time.</span><br></pre></td></tr></table></figure><p>现在怎么办？好吧，不要混为一谈。一切都很好，你只需要了解Flask部署Web服务器的用途，缺少的什么以及拿什么东西顶上就好了。</p><h4 id="Flask的内置Web服务器"><a href="#Flask的内置Web服务器" class="headerlink" title="Flask的内置Web服务器"></a>Flask的内置Web服务器</h4><p>Flask提供的内置 Web服务器是为了方便开发。</p><p>有了它，你就可以在本地计算机上访问你的应用程序，而无需开启其他服务并让它们协调工作。但是，它只能一次由一个人使用，<br>它就是以这种方式构建的–<strong>就是为了方便你开发</strong>。它也可以提供静态文件，但是与为快速处理文件而设计的工具(如nginx)相比，<br>这样做的速度非常慢。当只有一个人访问它时，这无关紧要，只要达到开发调试的目的就可以了。</p><p>在生产环境中运行Web应用程序时，我们希望它能够处理多个用户的过个请求，而那些使用我们服务的人不必为加载页面和静态文件焦急等待。</p><h4 id="生产栈结构"><a href="#生产栈结构" class="headerlink" title="生产栈结构"></a>生产栈结构</h4><p>生产环境的设置通常由多个组件组成，每个组件的设计和构建都非常擅长于同一件事–快速，可靠，专注。</p><p>就像内置Web服务器一样，与整个设备的通信都是通过HTTP进行的。一个请求进入并到达第一个组件-专用的Web服务器。<br>它非常适合从磁盘读取静态文件（例如，你的css，js文件）并处理多个请求。当请求不是静态文件时，<br>所有请求都将传递到堆栈中。</p><p>应用程序服务器获取这些的请求，并将这些请求中的信息转换为框架可以使用的Python对象-WSGI。</p><p>Flask应用实际上并未像我们想象的作为服务器等待请求并对它们做出反应。<br>而是可以被认为是被应用服务器作为方法调用，提供请求对象。</p><p>然后，应用程序服务器将运行应用程序的输出打包到HTTP响应中，并传递回Web服务器，再传递回给用户。</p><p>意思是<br>如果要在生产环境中运行Flask，请确保使用可用于生产环境的Web服务器，例如Nginx，并让你的应用程序由WSGI应用程序服务器（例如Gunicorn）处理。</p><p>完毕！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不要再用flask-run-部署项目了！&quot;&gt;&lt;a href=&quot;#不要再用flask-run-部署项目了！&quot; class=&quot;headerlink&quot; title=&quot;不要再用flask.run()部署项目了！&quot;&gt;&lt;/a&gt;不要再用flask.run()部署项目了！&lt;/h3&gt;&lt;p&gt;在维护公司老项目,服务器查看运行着一个flask项目。用简单的单进程跑在机器上。&lt;br&gt;查看详细的信息，发现是直接用这种方式运行的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def route1():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run(....)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>flask应用上下文和请求上下文</title>
    <link href="http://yoursite.com/2019/09/23/flask%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87&amp;%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://yoursite.com/2019/09/23/flask应用上下文&amp;请求上下文/</id>
    <published>2019-09-23T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask应用上下文和请求上下文"><a href="#flask应用上下文和请求上下文" class="headerlink" title="flask应用上下文和请求上下文"></a>flask应用上下文和请求上下文</h2><p>虽然现在已经是python3的时代，一些开发库已经不支持python2并且asyncio也越来越多的被应用。<br>但是个人感觉如果要解决高并发问题，使用asyncio并不是很好的实践。</p><a id="more"></a><p>因为协程之间并不是简单的调用切换，还涉及到一些协程间通信。<br>使用python还是以‘顺序’编程为主，如果公司对高并发真的是有急迫的需求，更好的选择应该是<code>golang</code></p><p>与<code>flask</code>对应的异步web框架是<code>sanic</code>。两者的编程风格很相似，包括核心app的构建方法，路由等。<br><code>sanic</code>是基于asyncio的事件回调机制来完成的，与tornado（老版的tornado是基于yield实现的类似于协程的切换）相比，性能及可读性更高一些。</p><p>我个人实际开发中对并发并没有很高的要求，所以应用最多的还是flask，原因很简单-需求驱动。</p><p>简单整理了flask的应用上下文和请求上下文的处理过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flask.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flask应用上下文和请求上下文&quot;&gt;&lt;a href=&quot;#flask应用上下文和请求上下文&quot; class=&quot;headerlink&quot; title=&quot;flask应用上下文和请求上下文&quot;&gt;&lt;/a&gt;flask应用上下文和请求上下文&lt;/h2&gt;&lt;p&gt;虽然现在已经是python3的时代，一些开发库已经不支持python2并且asyncio也越来越多的被应用。&lt;br&gt;但是个人感觉如果要解决高并发问题，使用asyncio并不是很好的实践。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch－基础介绍及索引原理分析</title>
    <link href="http://yoursite.com/2019/09/13/elaskticsearch/"/>
    <id>http://yoursite.com/2019/09/13/elaskticsearch/</id>
    <published>2019-09-13T13:47:23.000Z</published>
    <updated>2019-11-03T08:29:42.514Z</updated>
    
    <content type="html"><![CDATA[<p>#Elasticsearch－基础介绍及索引原理分析</p><p>最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。</p><a id="more"></a><p>##介绍<br>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p><ul><li><p>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</p></li><li><p>实时分析的分布式搜索引擎。</p></li><li><p>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</p></li></ul><p>##基本概念<br>先说Elasticsearch的文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据：</p><p>{<br>“name” : “John”,<br>“sex” : “Male”,<br>“age” : 25,<br>“birthDate”: “1990/05/01”,<br>“about” : “I love to go rock climbing”,<br>“interests”: [ “sports”, “music” ]<br>}<br>用Mysql这样的数据库存储就会容易想到建立一张User表，有balabala的字段等，在Elasticsearch里这就是一个文档，当然这个文档会属于一个User的类型，各种各样的类型存在于一个索引当中。这里有一份简易的将Elasticsearch和关系型数据术语对照表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)</span><br><span class="line"></span><br><span class="line">Elasticsearch ⇒ 索引(Index) ⇒ 类型(type) ⇒ 文档(Docments) ⇒ 字段(Fields)</span><br></pre></td></tr></table></figure><p>一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式，比如我们打算插入一条记录，可以简单发送一个HTTP的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot; : &quot;John&quot;,</span><br><span class="line">&quot;sex&quot; : &quot;Male&quot;,</span><br><span class="line">&quot;age&quot; : 25,</span><br><span class="line">&quot;about&quot; : &quot;I love to go rock climbing&quot;,</span><br><span class="line">&quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新，查询也是类似这样的操作，具体操作手册可以参见Elasticsearch权威指南</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Elasticsearch最关键的就是提供强大的索引能力了，其实InfoQ的这篇时间序列数据库的秘密(2)——索引写的非常好，我这里也是围绕这篇结合自己的理解进一步梳理下，也希望可以帮助大家更好的理解这篇文章。<br>Elasticsearch索引的精髓：</p><blockquote><p>一切设计都是为了提高搜索的性能</p></blockquote><p>另一层意思：为了提高搜索的性能，难免会牺牲某些其他方面，比如插入/更新，否则其他数据库不用混了。前面看到往Elasticsearch里插入一条记录，其实就是直接PUT一个json的对象，这个对象有多个fields，比如上面例子中的name, sex, age, about, interests，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默1的为这些字段建立索引–倒排索引，因为Elasticsearch最核心功能是搜索。<br>###Elasticsearch是如何做到快速索引的<br>InfoQ那篇文章里说Elasticsearch使用的倒排索引比关系型数据库的B-Tree索引快，为什么呢？<br>###什么是B-Tree索引?<br>上大学读书时老师教过我们，二叉树查找效率是logN，同时插入新的节点不必移动全部节点，<br>所以用树型结构存储索引，能同时兼顾插入和查询的性能。因此在这个基础上，<br>再结合磁盘的读取特性(顺序读/随机读)，传统关系型数据库采用了B-Tree/B+Tree这样的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/b-tree.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，<br>一次寻道读取多个数据，同时也降低树的高度。<br>###什么是倒排索引?</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/inverted-index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>继续上面的例子，假设有这么几条数据(为了简单，去掉about, interests这两个field):</p><table><thead><tr><th>ID</th><th align="center">Name</th><th align="right">Age</th><th align="right">Sex</th></tr></thead><tbody><tr><td>1</td><td align="center">Kate</td><td align="right">24</td><td align="right">Female</td></tr><tr><td>2</td><td align="center">John</td><td align="right">24</td><td align="right">Male</td></tr><tr><td>3</td><td align="center">Bill</td><td align="right">29</td><td align="right">Male</td></tr></tbody></table><p>ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下:<br>Name:</p><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Kate</td><td align="center">1</td></tr><tr><td>John</td><td align="center">2</td></tr><tr><td>Bill</td><td align="center">3</td></tr><tr><td>Age:</td><td align="center"></td></tr></tbody></table><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>24</td><td align="center">[1,2]</td></tr><tr><td>29</td><td align="center">3</td></tr><tr><td>Sex:</td><td align="center"></td></tr></tbody></table><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Female</td><td align="center">1</td></tr><tr><td>Male</td><td align="center">[2,3]</td></tr></tbody></table><ul><li>Posting List</li></ul><p>Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而[1,2]就是Posting List。Posting list就是一个int的数组，存储了所有符合某个term的文档id。<br>看到这里，不要认为就结束了，精彩的部分才刚开始…<br>通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，爱回答问题的小明马上就举手回答：我知道，id是1，2的同学。但是，如果这里有上千万的记录呢？如果是想通过name来查找呢？</p><ul><li>Term Dictionary</li></ul><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。现在再看起来，似乎和传统数据库通过B-Tree的方式类似啊，为什么说比B-Tree的查询快呢？</p><ul><li>Term Index</li></ul><p>B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/term-index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。<br>这时候爱提问的小明又举手了:”那个FST是神马东东啊?”<br>一看就知道小明是一个上大学读书的时候跟我一样不认真听课的孩子，<br>数据结构老师一定讲过什么是FST。但没办法，我也忘了，这里再补下课：</p><blockquote><p>FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output.</p></blockquote><p>假设我们现在要将mop, moth, pop, star, stop and top(term index里的term前缀)映射到序号：0，1，2，3，4，5(term dictionary的block位置)。最简单的做法就是定义个Map&lt;string, integer=””&gt;，大家找到自己的位置对应入座就好了，但从内存占用少的角度想想，有没有更优的办法呢？答案就是：FST(<a href="http://www.cs.nyu.edu/~mohri/pub/fla.pdf" target="_blank" rel="noopener">理论依据在此，但我相信99%的人不会认真看完的</a>)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/fst.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>⭕️表示一种状态<br>–&gt;表示状态的变化过程，上面的字母/数字表示状态变化和权重<br>将单词分成单个字母通过⭕️和–&gt;表示出来，0权重不显示。如果⭕️后面出现分支，就标记权重，最后整条路径上的权重加起来就是这个单词对应的序号。<br><code>FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output.</code></p><p>FST以字节的方式存储所有的term，这种压缩方式可以有效的缩减存储空间，使得term index足以放进内存，但这种方式也会导致查找时需要更多的CPU资源。<br>后面的更精彩，看累了的同学可以喝杯咖啡……</p><h3 id="压缩技巧"><a href="#压缩技巧" class="headerlink" title="压缩技巧"></a>压缩技巧</h3><p>Elasticsearch里除了上面说到用FST压缩term index外，对posting list也有压缩技巧。<br>小明喝完咖啡又举手了:”posting list不是已经只存储文档id了吗？还需要压缩？”<br>嗯，我们再看回最开始的例子，如果Elasticsearch需要对同学的性别进行索引(这时传统关系型数据库已经哭晕在厕所……)，会怎样？如果有上千万个同学，而世界上只有男/女这样两个性别，每个posting list都会有至少百万个文档id。<br>Elasticsearch是如何有效的对这些文档id压缩的呢？</p><ul><li>Frame Of Reference</li></ul><blockquote><p>增量编码压缩，将大数变小数，按字节存储</p></blockquote><p>首先，Elasticsearch要求posting list是有序的(为了提高搜索的性能，再任性的要求也得满足)，这样做的一个好处是方便压缩，看下面这个图例：</p><p><img src="/images/frameOfReference.png" alt=""><br>如果数学不是体育老师教的话，还是比较容易看出来这种压缩技巧的。<br>原理就是通过增量，将原来的大数变成小数仅存储增量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字节)来存储。<br><strong>Roaring bitmaps</strong></p><p>说到Roaring bitmaps，就必须先从bitmap说起。Bitmap是一种数据结构，假设有某个posting list：<br><code>[1,3,4,7,10]</code><br>对应的bitmap就是：<br><code>[1,0,1,1,0,0,1,0,0,1]</code><br>非常直观，用0/1表示某个值是否存在，比如10这个值就对应第10位，对应的bit值是1，这样用一个字节就可以代表8个文档id，旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段(我们往往会有很多个索引字段)。于是有人想出了Roaring bitmaps这样更高效的数据结构。<br>Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性：<br>将posting list按照65535为界限分块，比如第一块所包含的文档id范围在0<del>65535之间，第二块的id范围是65536</del>131071，以此类推。再用&lt;商，余数&gt;的组合表示每一组id，这样每组里的id范围都在0~65535内了，剩下的就好办了，既然每组id不会变得无限大，那么我们就可以通过最有效的方式对这里的id存储。</p><p>细心的小明这时候又举手了:”为什么是以65535为界限?”<br>程序员的世界里除了1024外，65535也是一个经典值，因为它=2^16-1，正好是用2个字节能表示的最大数，一个short的存储单位，注意到上图里的最后一行“If a block has more than 4096 values, encode as a bit set, and otherwise as a simple array using 2 bytes per value”，如果是大块，用节省点用bitset存，小块就豪爽点，2个字节我也不计较了，用一个short[]存着方便。<br>那为什么用4096来区分大块还是小块呢？<br>个人理解：都说程序员的世界是二进制的，4096*2bytes ＝ 8192bytes &lt; 1KB, 磁盘一次寻道可以顺序把一个小块的内容都读出来，再大一位就超过1KB了，需要两次读。</p><ul><li><strong>联合索引</strong></li></ul><p>上面说了半天都是单field索引，如果多个field索引的联合查询，倒排索引如何满足快速查询的要求呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 利用跳表(Skip list)的数据结构快速做“与”运算，或者</span><br><span class="line"></span><br><span class="line">- 利用上面提到的bitset按位“与”</span><br></pre></td></tr></table></figure><p>先看看跳表的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/skiplist.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时依次从高level往低查找，比如55，先找到level2的31，再找到level1的47，最后找到55，一共3次查找，查找效率和2叉树的效率相当，但也是用了一定的空间冗余来换取的。<br>假设有下面三个posting list需要联合索引：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/combineIndex.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果。<br>如果使用bitset，就很直观了，直接按位与，得到的结果就是最后的交集。总结和思考<br>Elasticsearch的索引思路:</p><blockquote><p>将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。</p></blockquote><p>所以，对于使用Elasticsearch进行索引时需要注意:</p><ul><li><p>不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的</p></li><li><p>同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的</p></li><li><p>选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询</p></li></ul><p>关于最后一点，个人认为有多个因素:<br>其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高；<br>另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数，具体可以参考这篇如何选择一个高效的全局ID方案(评论也很精彩)</p><p>转自神一般的存在，<a href="http://blog.pengqiuyuan.com/ji-chu-jie-shao-ji-suo-yin-yuan-li-fen-xi/" target="_blank" rel="noopener">文章链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Elasticsearch－基础介绍及索引原理分析&lt;/p&gt;
&lt;p&gt;最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>实现tornado login_required()</title>
    <link href="http://yoursite.com/2019/08/01/tornado-login-required/"/>
    <id>http://yoursite.com/2019/08/01/tornado-login-required/</id>
    <published>2019-08-01T06:20:20.000Z</published>
    <updated>2019-11-04T17:15:57.581Z</updated>
    
    <content type="html"><![CDATA[<p>tornado作为鼎鼎大名的web异步框架，用来作为高性能服务器以及web框架都是首选。自从python3.4加入了asyncio原生协程后，tornado的最新版本也开始使用了原生的协程。定义协程函数的时候就很简单了，也可以像sanic一样使用async def了。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LoginHandler(RequestHandler):</span><br><span class="line">    async def post(self, *args, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>一般的web项目都会有登陆的功能，这就涉及到了登陆验证，在做这一部分功能的时候，我使用的是 jwt – json web token的方法验证是否登陆。当然也可以使用类似于django的session验证。各自均有优缺点。</p><p>通常需要验证是否登陆的模块很多，一般都会写一个登陆验证装饰器，tornado实现了登陆验证装饰器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def authenticated(method):</span><br><span class="line">    &quot;&quot;&quot;Decorate methods with this to require that the user be logged in.</span><br><span class="line"></span><br><span class="line">    If the user is not logged in, they will be redirected to the configured</span><br><span class="line">    `login url &lt;RequestHandler.get_login_url&gt;`.</span><br><span class="line"></span><br><span class="line">    If you configure a login url with a query parameter, Tornado will</span><br><span class="line">    assume you know what you&apos;re doing and use it as-is.  If not, it</span><br><span class="line">    will add a `next` parameter so the login page knows where to send</span><br><span class="line">    you once you&apos;re logged in.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @functools.wraps(method)</span><br><span class="line">    def wrapper(self, *args, **kwargs):</span><br><span class="line">        if not self.current_user:</span><br><span class="line">            if self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;):</span><br><span class="line">                url = self.get_login_url()</span><br><span class="line">                if &quot;?&quot; not in url:</span><br><span class="line">                    if urlparse.urlsplit(url).scheme:</span><br><span class="line">                        # if login url is absolute, make next absolute too</span><br><span class="line">                        next_url = self.request.full_url()</span><br><span class="line">                    else:</span><br><span class="line">                        next_url = self.request.uri</span><br><span class="line">                    url += &quot;?&quot; + urlencode(dict(next=next_url))</span><br><span class="line">                self.redirect(url)</span><br><span class="line">                return</span><br><span class="line">            raise HTTPError(403)</span><br><span class="line">        return method(self, *args, **kwargs)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>method(self,<em>args,*</em>kwargs)即为要装饰的函数。但是如果 像上面定义的post方法 async def post(self, <em>args, *</em>kwargs),作为一个协程函数，就不能再使用这个装饰器了，就需要改写一下这个装饰器。def authenticated_async(method):</p><p>初始化app的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import tornado</span><br><span class="line">from peewee_async import Manager</span><br><span class="line"></span><br><span class="line">from YourApp.urls import urlpattern</span><br><span class="line">from YourApp.settings import settings, database</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    #集成json到wtforms</span><br><span class="line">    import wtforms_json</span><br><span class="line">    wtforms_json.init()</span><br><span class="line"></span><br><span class="line">    app = web.Application(urlpattern, debug=True, **settings)</span><br><span class="line">    app.listen(80)</span><br><span class="line"></span><br><span class="line">    objects = Manager(database)</span><br><span class="line">    database.set_allow_sync(False)</span><br><span class="line">    app.objects = objects</span><br><span class="line"></span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>登陆装饰器改写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@functools.wraps(method)</span><br><span class="line">async def wrapper(self, *args, **kwargs):</span><br><span class="line">    tsessionid = self.request.headers.get(&quot;tsessionid&quot;, None)</span><br><span class="line">    if tsessionid:</span><br><span class="line">        try:</span><br><span class="line"></span><br><span class="line">            send_data = jwt.decode(tsessionid, self.settings[&quot;secret_key&quot;], leeway=self.settings[&quot;jwt_expire&quot;], options=&#123;&quot;verify_exp&quot;: True&#125;)</span><br><span class="line">            user_id = send_data[&quot;id&quot;]</span><br><span class="line">            # User 的model类，根据实际情况调整</span><br><span class="line">            #从数据库中获取到user并设置给_current_user</span><br><span class="line">            try:</span><br><span class="line">                user = await self.application.objects.get(User, id=user_id)</span><br><span class="line">                self._current_user = user</span><br><span class="line"></span><br><span class="line">                # 协程的调用方式</span><br><span class="line">                await method(self, *args, **kwargs)</span><br><span class="line">            except User.DoesNotExist as e:</span><br><span class="line">                self.set_status(401)</span><br><span class="line">        except jwt.ExpiredSignatureError as e: # 验证jwt 是否过期</span><br><span class="line">            self.set_status(401)</span><br><span class="line">    else:</span><br><span class="line">        self.set_status(401)</span><br><span class="line">    self.finish(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">return wrapper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado作为鼎鼎大名的web异步框架，用来作为高性能服务器以及web框架都是首选。自从python3.4加入了asyncio原生协程后，tornado的最新版本也开始使用了原生的协程。定义协程函数的时候就很简单了，也可以像sanic一样使用async def了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="后端" scheme="http://yoursite.com/categories/python/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocks源码解读</title>
    <link href="http://yoursite.com/2019/07/20/shadowsockts%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/07/20/shadowsockts源码解读/</id>
    <published>2019-07-20T04:00:40.000Z</published>
    <updated>2019-11-04T17:15:57.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shadowsocks源码解读"><a href="#shadowsocks源码解读" class="headerlink" title="shadowsocks源码解读"></a>shadowsocks源码解读</h2><p>经常使用shadowsocks科学上网，但是一直没有时间去看一看人家怎么写的。<br>先记录一下一篇写的很详细的博客，这篇就当书签用啦。<br><a href="https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html" target="_blank" rel="noopener">Shadowsocks 源码分析——协议与结构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;shadowsocks源码解读&quot;&gt;&lt;a href=&quot;#shadowsocks源码解读&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks源码解读&quot;&gt;&lt;/a&gt;shadowsocks源码解读&lt;/h2&gt;&lt;p&gt;经常使用shadowsocks科学上
      
    
    </summary>
    
    
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>queue.Queue 和mutiprocessing.Queue</title>
    <link href="http://yoursite.com/2019/06/17/queue-Queue%20and%20multiprocessing-Queue/"/>
    <id>http://yoursite.com/2019/06/17/queue-Queue and multiprocessing-Queue/</id>
    <published>2019-06-17T03:09:40.000Z</published>
    <updated>2019-11-04T17:18:24.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这两个队列到底有什么不一样，又分别能在什么场景下使用呢"><a href="#这两个队列到底有什么不一样，又分别能在什么场景下使用呢" class="headerlink" title="这两个队列到底有什么不一样，又分别能在什么场景下使用呢?"></a>这两个队列到底有什么不一样，又分别能在什么场景下使用呢?</h2><p>queue.Queue只是一个内存队列，在多线程下使用。如果错误得用在了多进程中，那么每个进程都会创建一个Queue的实例,<br>因为进程不再共享<a id="more"></a>相同的内存。<br>也就是仅当生产者和消费者处于同一进程中时，这个Queue才能达到预期的效果。<br>看一下queue.Queue的初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, maxsize=0):</span><br><span class="line">    self.maxsize = maxsize</span><br><span class="line">    self._init(maxsize)</span><br><span class="line"></span><br><span class="line">    # mutex must be held whenever the queue is mutating.  All methods</span><br><span class="line">    # that acquire mutex must release it before returning.  mutex</span><br><span class="line">    # is shared between the three conditions, so acquiring and</span><br><span class="line">    # releasing the conditions also acquires and releases mutex.</span><br><span class="line">    self.mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line">    # Notify not_empty whenever an item is added to the queue; a</span><br><span class="line">    # thread waiting to get is notified then.</span><br><span class="line">    self.not_empty = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    # Notify not_full whenever an item is removed from the queue;</span><br><span class="line">    # a thread waiting to put is notified then.</span><br><span class="line">    self.not_full = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    # Notify all_tasks_done whenever the number of unfinished tasks</span><br><span class="line">    # drops to zero; thread waiting to join() is notified to resume</span><br><span class="line">    self.all_tasks_done = threading.Condition(self.mutex)</span><br><span class="line">    self.unfinished_tasks = 0</span><br></pre></td></tr></table></figure><p>在多进程应用场景中，如果多个进程需要共享数据，那么就不能使用queue.Queue了。<br>而应该使用可以共享内存的管道或套接字，也可以是其他东西-multiprocessing.Queue。它使用管道为两个进程进行通信提供一种方式。而这两个Queue又<br>恰好实现了与相同的API，因为大多数Python程序员已经非常熟悉它。</p><p>下面一段代码在Windows环境下会报错 <code>TypeError: can&#39;t pickle _thread.lock objects</code>：<br>进程池内部处理使用了pickle模块用于python特有的类型和python的数据类型间进行转换。<br>pickle模块要对内部的成员变量进行序列化，但不支持对自定义对象加锁，所以会抛出类型异常的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool, Process,Queue,JoinableQueue</span><br><span class="line">import os, time</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">def write(q): </span><br><span class="line">    for v in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: </span><br><span class="line">        print(&apos;Put %s to queue &apos; % v)</span><br><span class="line">        q.put_nowait(v) </span><br><span class="line">        time.sleep(0.2) </span><br><span class="line"></span><br><span class="line">def read(q): </span><br><span class="line">    while 1: </span><br><span class="line">        if not q.empty(): </span><br><span class="line">            v = q.get(True) </span><br><span class="line">            print(&quot;Get %s from queue&quot; % v)</span><br><span class="line">            time.sleep(0.2) </span><br><span class="line">        else: </span><br><span class="line">            break </span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;: </span><br><span class="line">    q = Queue() </span><br><span class="line">    pw = Process(target=write, args=(q, )) </span><br><span class="line">    pr = Process(target=read, args=(q, )) </span><br><span class="line">    pw.start() </span><br><span class="line">    pw.join() </span><br><span class="line"></span><br><span class="line">    pr.start() </span><br><span class="line">    pr.join() </span><br><span class="line"></span><br><span class="line">    print(&quot;all done...&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这两个队列到底有什么不一样，又分别能在什么场景下使用呢&quot;&gt;&lt;a href=&quot;#这两个队列到底有什么不一样，又分别能在什么场景下使用呢&quot; class=&quot;headerlink&quot; title=&quot;这两个队列到底有什么不一样，又分别能在什么场景下使用呢?&quot;&gt;&lt;/a&gt;这两个队列到底有什么不一样，又分别能在什么场景下使用呢?&lt;/h2&gt;&lt;p&gt;queue.Queue只是一个内存队列，在多线程下使用。如果错误得用在了多进程中，那么每个进程都会创建一个Queue的实例,&lt;br&gt;因为进程不再共享
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
