<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHERPA-ZARIC</title>
  
  <subtitle>在神秘的珠穆朗玛峰，有一个为世界各国登山队充当向导与挑夫的族群——夏尔巴人 （SHERPA）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-06T14:58:47.109Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZARIC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库优化设计方法初探</title>
    <link href="http://yoursite.com/2019/11/06/sql-index-condition-md/"/>
    <id>http://yoursite.com/2019/11/06/sql-index-condition-md/</id>
    <published>2019-11-06T14:58:47.108Z</published>
    <updated>2019-11-06T14:58:47.109Z</updated>
    
    <content type="html"><![CDATA[<p>##数据库优化设计方法初探</p><p>随着数据库技术的发展，人们越来越依赖于计<br>算机化的业务数据。但由于传统的基于文件的数据<br>存储和检索方法不灵活且难于管理，因而数据库优<br>化设计成为人们关注的问题。如何有效地组织和处<br>理大型数据库的海量数据，使得人们能方便、准确、<br>快捷地完成对数据的存取操作，成为对数据库的建<br>设及使用的瓶颈。</p><p>运行速度及执行效率是衡量数据库系统性能的<br>重要标准，为了保证系统性能和吞吐量，需要对数据<br>库的逻辑设计和物理设计进行优化，并贯穿于数据库设计的始终，这就是数据库优化设计的首要任务。<br>本文从范式优化、索引优化、表的优化及查询优化四<br>个方面探讨数据库优化设计的方法，并对它们的综<br>合使用进行分析。</p><p>###1范式优化</p><p>数据库逻辑设计的结果不是惟一的，好的关系<br>模式通常需要满足2个条件：正确表达数据语义和<br>避免数据冗余、异常及不一致问题的出现。设计过程<br>中，要从这2个基本条件出发，不要顾此失彼，这样<br>才能在提高数据库性能的同时保证数据库的正确<br>性。<br>将模式的范式作为评价关系模式优劣的标准具<br>有一定的科学性。通常一个关系模式达到BCNF或<br>3NF时，被认为具有较好的性能。当某关系模式达到BCNF时，可以有效消除数据冗余和异常现象，<br>但有时不一定保持原关系模式的函数依赖关系，破<br>坏了数据语义。因此在设计时应统筹兼顾，先尽可能<br>设计成BCNF模式集，若此时达不到保持函数依赖<br>的特点，则降低范式要求，改成3NF模式集，以保证<br>模式集正确地表达数据语义。</p><p>###索引优化<br>索引是数据库中重要的数据结构，它的根本目<br>的是为了提高查询效率，改善系统性能。但对索引的<br>存储和维护操作的同时会给系统的空间和时间上带<br>来一些负面影响，牺牲一定的系统性能。因此设计时<br>应尽量选择有用的索引，在提高查询速度和节省存<br>储空间之间寻求最佳的平衡点：</p><p>(1)在大型关系数据库中，若处理的关系表较<br>小，则无需建立索引。因为数据量较小时，直接扫描<br>便可很快遍历整个表，建立索引反而会加重系统负<br>担。</p><p>(2)如果数据的更新比较频繁，维护索引所付出<br>的代价则很大，若这种代价超出了查询上所获得的<br>好处，此时索引不可取。</p><p>(3)选择合适的列建立索引对平衡索引的正负<br>面影响有重要作用。通常在有如下特性的数据列建<br>立索引：</p><pre><code>①定义有主键和外键的数据列；②需要在指定范围中快速或频繁查询的列；③需要按排序顺序快速或频繁检索的列；④在集合过程中需要快速或频繁组合到一起的列。</code></pre><p>如有下列情况时则不考虑创建索引L2]：</p><pre><code>①在查询中几乎不涉及的列；②不同值少的列，比如在学生表的“性别”列上只有“男”与“女”2个不同值，就无必要建立索引；③由文本、图像等数据类型定义的列。</code></pre><p>(4)索引分为聚集索引和非聚集索引，建立索引时，应考虑对两者的选择：</p><pre><code>①经常作为查询结果排序条件的字段应建为聚集索引。例如查询结果要对年龄排序，可在年龄字段上建立聚集索引；②当以某字段为查询条件，需要回传局部范围的大量数据时，应在此字段上建立聚集索引，而当查询所获得的数据量较少时，有必要在此字段上建立非聚集索引。例如回传某个时间段之间的数据，可考虑在日期字段上建聚集索引；③应在内容重复性较大的字段上建立聚集索引，而当某字段的数据惟一性较高时，有必要建立非聚集索引。例如学生的成绩重复性较大，可考虑在成绩字段上建立聚集索引对索引列和索引类型的选择没有绝对的界限，在实际应用中，要综合各要素点具体分析，以达到系统的性能综合最优。</code></pre><h3 id="3查询优化"><a href="#3查询优化" class="headerlink" title="3查询优化"></a>3查询优化</h3><p>在数据库的所有操作中，查询操作占有很大的<br>比例，查询速度的快慢直接影响到应用系统的生命<br>力，因此设计较为优化的查询语句对提高数据库的<br>整体性能有着重要的作用。实践证明，在许多情况下<br>均可找到语义等价的查询，而选择不同的查询语句<br>对查询效率的影响大不相同，尤其是在一些大规模<br>的关系数据库应用系统中更加明显。本文以应用实<br>例为基础，结合数据库理论，探讨查询优化技术在现<br>实系统中的运用。<br>设在某学生管理系统中有如下3个关系：</p><pre><code>(1)学生登记表S(学号SN0，姓名SNAME，年龄AGE，性别SEX，院系SDEPT)；(2)学习登记表SC(学号SNO ，课程号CN0，成绩GRADE)；(3)课程登记表C(课程号CN()，课程名</code></pre><p>CNAME，开课院系CDEPT，教师TNAME)。</p><p>####3．1在条件子旬中使用索引</p><p>正确使用索引可以大大提高查询效率，在条件<br>子句中应尽量考虑以下有用索引的使用。</p><h5 id="1-使用单列索引。"><a href="#1-使用单列索引。" class="headerlink" title="(1)使用单列索引。"></a>(1)使用单列索引。</h5><p>例如，在学生登记表中，如果创建学号为单列索<br>引，那么下列查询语句的 WHERE 子句中应使用学<br>号这个索引，使之成为有用索引。如果使用了其他字<br>段，创建学号这个索引则为无用索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  SNO ，SNAME，SEX</span><br><span class="line">FR0M S</span><br><span class="line"> WHERE  SNO =’S1’</span><br></pre></td></tr></table></figure><p>#####(2)使用复合索引时，必须保证在条件子句中首先使用复合索引的第一列。<br>例如，在学习登记表中，如果创建学号和课程号<br>为复合索引，下列查询中复合索引的使用是有用的，<br>因为SN0是复合索引的第一列字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT SN0．GRADE</span><br><span class="line">FR0MSC</span><br><span class="line"> WHERE SNO =’S3’AND CNO =’C1’</span><br></pre></td></tr></table></figure><p>但是，下列复合索引的使用是没用的，系统仍然<br>采用顺序扫描方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  SN0，GRADE</span><br><span class="line">FR0M SC</span><br><span class="line"> WHERE  CNO =’C1’ AND SNO =’S3’</span><br></pre></td></tr></table></figure><h4 id="3．2采用嵌套查询"><a href="#3．2采用嵌套查询" class="headerlink" title="3．2采用嵌套查询"></a>3．2采用嵌套查询</h4><p>嵌套查询(子查询)是指在 WHERE 或<br>HAVING条件子句中又包含了另一个SELECT 查<br>询语句的查询。执行时先执行最内层的子查询，再由<br>内到外逐层进行，通过子查询的层层选择、投影，中<br>间结果元组及属性的数目都得到有效的缩减，使条<br>件判断时的扫描工作仅限于较小范围内，提高检索<br>效率。嵌套查询比联接查询效率要高。</p><p>例如，查询选修课程名为“数据库原理”的学生<br>学号和姓名。</p><p>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO ，SNAME FROM  C，SC，S</span><br><span class="line"> WHERE  CNAME=’数据库原理’AND C．</span><br><span class="line">CNO =SC．CNO </span><br><span class="line">AND SC．SNO =S．SNO</span><br></pre></td></tr></table></figure><p>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO ，SNAME FROM  S</span><br><span class="line"> WHERE  SN0 IN</span><br><span class="line">(SELECT SNO  FROM  SC  WHERE  CNO  IN</span><br><span class="line">(SELECT CNO  FROM  C  WHERE  CNAME=</span><br><span class="line">’数据库原理’))</span><br></pre></td></tr></table></figure><p>由于查询1采用联接查询，只有学号和姓名为<br>输出属性，但几乎所有届性都要参加选择、联接运<br>算，多余的属性占用了较大的内存空间；另外3个表<br>的笛卡尔积将产生大量的中间结果，使选择操作时<br>需处理大量数目的元组。</p><p>查询2采用子查询，投影和选择运算同时进行，<br>对C表进行扫描选择后，仅剩下少量满足条件的元<br>组，接着投影操作将其它属性统统剔除，只保留“课<br>程号”一个属性，这样产生一个元组数目和属性数目<br>都较小的中间结果，大大减少了其外层对SC表查<br>询时的比较次数；同理，对SC表的扫描结果又减少<br>了其外层对S表查询时的比较次数。从而提高了检<br>索效率。</p><p>这里需要指出的是，使用嵌套查询时，要避免采<br>用相关子查询。即子查询中查询条件依赖于外层查<br>询中的某个值，当主查询中的列值改变之后，子查询<br>必须重新查询一次，查询嵌套层次越多，效率越低，<br>比联接查询的效率更低。</p><p>####3．3尽早执行选择操作<br>尽可能早地执行选择操作，以减少运算量。例<br>如，检索选修课程名为“高数”的学生的学号和姓名。<br>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.SNO ，S.SNAME</span><br><span class="line">FROM S，C，SC</span><br><span class="line"> WHERE C.CNO =SC.CNO AND SC．SNO =S．SNO AND CNAME=’高数’</span><br></pre></td></tr></table></figure><p>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.SNO ，S.SNAME</span><br><span class="line">FROM S，C，SC</span><br><span class="line"> WHERE CNAME=’高数’AND C.CNO </span><br><span class="line">=SC.CNO AND SC.SNO =S.SNO</span><br></pre></td></tr></table></figure><p>执行这两条查询语句时，在对表S、C和SC笛<br>卡尔积的中间结果筛选时，查询2执行的比较次数<br>较查询1要少，因为其首先利用是否选修高数这一<br>条件排除了大量的元组，只有满足此条件的元组才<br>需要进行课程号和学号的相等判断。</p><h4 id="3．4尽早消掉不满足条件的记录"><a href="#3．4尽早消掉不满足条件的记录" class="headerlink" title="3．4尽早消掉不满足条件的记录"></a>3．4尽早消掉不满足条件的记录</h4><p>having子句中的限制条件应尽量多地放人<br> WHERE 子句中，以尽早把不满足条件的记录消掉。</p><p>例如，分别统计选修C1和C2课程的学生人<br>数，当选修超过50人时，显示学生的学号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO FROM SC</span><br><span class="line">GROUP BY CN0</span><br><span class="line">HAVING(CNO =’C1’ OR CNO =’C2’) AND</span><br><span class="line">C0UNT(*)&gt;50</span><br></pre></td></tr></table></figure><p>应改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNO FROM SC</span><br><span class="line"> WHERE CNO =’C1’ OR CNO =’C2’</span><br><span class="line">GROUPBY CNO </span><br><span class="line">HAVING COUNT(*)&gt;50</span><br></pre></td></tr></table></figure><p>3．5分组计数<br>例如，找出选修全部课程的学生姓名。<br>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNAME FROM S</span><br><span class="line"> WHERE NOT EXISTS</span><br><span class="line">(SELECT*FROM C WHERE NOT</span><br><span class="line">EXESTS</span><br><span class="line">(SELECT * FROM SC WHERE S.SNO =</span><br><span class="line">SC．SNO ANDC．CNO =SC.CNO ))</span><br></pre></td></tr></table></figure><p>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT SNAME FROM S WHERE SNO </span><br><span class="line">IN</span><br><span class="line">(SELECT DISTINCTS NO FROM SC</span><br><span class="line">GROUPBY SNO </span><br><span class="line">HAVING COUNT(CNO )=(SELECT</span><br><span class="line">COUNT(CNO )FROM C))</span><br></pre></td></tr></table></figure><p>由于全部课程构成1个集合，如果成绩登记表<br>按学号分组，只要比较每个学生选修的课程集合是<br>否与全部课程构成的集合相等，即可判断某学生是<br>否选修了全部课程。可以证明，对于有引用关系的集<br>合而言，集合中元素数目相等则集合相同，因此查询<br>条件中若某学生选的课程数目等于课程表的记录总<br>数时，表示该同学选修了全部课程。查询2较查询1<br>效率较高。</p><h4 id="3．6避免困难的正规表达式"><a href="#3．6避免困难的正规表达式" class="headerlink" title="3．6避免困难的正规表达式"></a>3．6避免困难的正规表达式</h4><p>正规表达式即为使用IIKE等关键字支持通配<br>符匹配，但这种匹配特别耗费时间。例如，从学生登<br>记表中选出以‘2000’为前缀的学号的学生。<br>查询1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *FROM S  WHERE SNO LIKE</span><br><span class="line">’2000</span><br></pre></td></tr></table></figure><p>一<br>’<br>查询2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *FROM S WHERE (SNO &gt;</span><br><span class="line">’2000000’)AND(SNO &lt;’2001000’)</span><br></pre></td></tr></table></figure><p>对于这两种查询，既使在学号字段上建立索引，<br>查询1仍是采用顺序扫描的方式，查询2则是利用<br>学号索引进行定位，显然大大提高了速度。</p><h3 id="4表的优化"><a href="#4表的优化" class="headerlink" title="4表的优化"></a>4表的优化</h3><p>数据库逻辑设计时，依据范化理论把数据划分<br>成多个相关的表。但随着规范化程度的增加，查询时<br>要求联接的表的数目和复杂性也随之增加，系统复<br>杂的联接运算将影响整体性能。另外对于某些查询<br>要求，使用单个查询语句获得查询结果是较困难的<br>工作，特别是对于大型数据库系统，不容易检查查询<br>结果，要确定查询的正确与否非常困难。针对这些情<br>况，通过引人临时表来简化查询。</p><p>例如，查询某个学生某门课程的成绩。这个查询<br>的使用频率较高，则对其建立一个临时表TEMPSC<br>(学号(SNO )、姓名(SNAME)、课程名(CNAME)、<br>教师(TNAME)、成绩(GRADE))，并将对表S、C及<br>SC的查询结果写人表TEMPSC中。后续查询时直<br>接对表TEMPSC操作即可，简化了查询工作。</p><p>又如查询具有最多女生的系的名称。使用单条<br>查询语句获得查询结果较为困难，则可建立临时表<br>TEMPW(院系(SDEPT)、人数(NUMBER))，先将<br>各院系女生人数的统计结果写人此表，再在表<br>TEMPW中查出人数最多的院系名称。通过分解操<br>作过程，使解决办法得以简化。</p><p>使用临时表时要注意对它的更新操作，以保持<br>与原始表之间数据的一致性。使用完毕后，应对其删<br>除，释放其所占用的空间。</p><h3 id="5结束语"><a href="#5结束语" class="headerlink" title="5结束语"></a>5结束语</h3><p>数据库的优化设计工作对提高系统执行效率起<br>着重要的作用，本文从关系模式的规范化，索引和临<br>时表的建立以及查询优化这几个重要技术的几个方<br>面对数据库优化方案进行探讨。实际运用时，首先在<br>逻辑设计阶段根据范式优化及表优化中的要求设计<br>数据库逻辑结构，对两者的利弊进行权衡，选出折衷<br>的方案，既避免不一致性和数据异常现象，又不影响<br>整体的性能；接着在数据库物理设计阶段根据索引<br>优化中的要求在有关属性或属性的组合上建立索<br>引，以优化数据库物理结构；最后，在数据库查询阶<br>段，采用本文给出，6种优化策略，可大大提高查询<br>效率。总之，数据库设计时，要根据具体情况将上述<br>几个方面的优化策略有机地结合起来，尽可能使系<br>统效率达到最优。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##数据库优化设计方法初探&lt;/p&gt;
&lt;p&gt;随着数据库技术的发展，人们越来越依赖于计&lt;br&gt;算机化的业务数据。但由于传统的基于文件的数据&lt;br&gt;存储和检索方法不灵活且难于管理，因而数据库优&lt;br&gt;化设计成为人们关注的问题。如何有效地组织和处&lt;br&gt;理大型数据库的海量数据，使得
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>python_variable_scope</title>
    <link href="http://yoursite.com/2019/11/05/python_variable_scope/"/>
    <id>http://yoursite.com/2019/11/05/python_variable_scope/</id>
    <published>2019-11-05T14:36:47.812Z</published>
    <updated>2019-11-05T14:36:47.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中的变量范围"><a href="#Python中的变量范围" class="headerlink" title="Python中的变量范围"></a>Python中的变量范围</h2><blockquote><p>关于变量的讨论虽然有很多博客，但是感觉大多数都没有深度，浅尝辄止。推荐一本书《流畅的python》<br>在第八章，对 对象的引用、可变性和垃圾回收有很详细和深度的讲解。我在这里也通过搜索的一些文章和这本书的<br>内容谈谈自己的见解，顺便也做一下笔记。</p></blockquote><p>如果您熟悉Python或任何其他编程语言，<br>你肯定会知道必须先定义变量，然后才能在程序中使用它们。<br>根据定义的方式和位置，必须以不同的方式访问变量。<br>有些变量是全局定义的，有些是局部定义的。<br>这意味着引用程序某个部分中的实体的变量，可能引用程序另一部分中的不同内容。</p><h2 id="到底是什么变量？"><a href="#到底是什么变量？" class="headerlink" title="到底是什么变量？"></a>到底是什么变量？</h2><p>要了解变量的范围，重要的是首先了解什么是变量。本质上，它们是内存中对象的引用或指针。将变量分配给=实例时，<br>就是将变量绑定（或映射）到该实例。<br>可以将多个变量绑定到同一实例。<br>Python使用名称空间跟踪所有这些映射。<br>这些是用于将变量名映射到对象的容器。你可以将它们视为包含name:object映射的字典。<br>可以通过选择分配给它们的名称访问对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = a</span><br><span class="line">a = 3</span><br></pre></td></tr></table></figure><p>在上面得实例中，a首先绑定到整数5。在这种情况下，a是变量名，整数5是对象<br>然后b设置为a。这实际上意味着b现在绑定到与a相同得整数值5.</p><p>如果随后把a改为4，有过这样经历得同学可能会认为b也会是3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = b = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; a[1] = 0</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 0, 3]</span><br></pre></td></tr></table></figure><p>值得注意的是 字符串、字节、和数字 等单一型序列是扁平的，它们保存的<br>不是引用，而是在链序的内存中保存数据本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python中的变量范围&quot;&gt;&lt;a href=&quot;#Python中的变量范围&quot; class=&quot;headerlink&quot; title=&quot;Python中的变量范围&quot;&gt;&lt;/a&gt;Python中的变量范围&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关于变量的讨论虽然有很多博客，但是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>golang一些有用的小技巧</title>
    <link href="http://yoursite.com/2019/11/02/golang%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/11/02/golang小技巧/</id>
    <published>2019-11-02T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化一个定时器"><a href="#初始化一个定时器" class="headerlink" title="初始化一个定时器"></a>初始化一个定时器</h2><p><a href="https://www.kancloud.cn/digest/batu-go/153534" target="_blank" rel="noopener">来源链接</a></p><p><code>ticker := time.NewTimer(2 * time.Second)</code><br>这样就初始化了一个2秒的定时器</p><p>再看一个实际的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    //初始化定时器</span><br><span class="line">    t := time.NewTimer(2 * time.Second)</span><br><span class="line">    //当前时间</span><br><span class="line">    now := time.Now()</span><br><span class="line">    fmt.Printf(&quot;Now time : %v.\n&quot;, now)</span><br><span class="line"></span><br><span class="line">    expire := &lt;- t.C</span><br><span class="line">    fmt.Printf(&quot;Expiration time: %v.\n&quot;, expire)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以time包的NewTimer可以应用在一些调度任务中</p><p>再看一下复杂点的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main()&#123;</span><br><span class="line">    //初始化通道</span><br><span class="line">    ch11 := make(chan int, 1000)</span><br><span class="line">    sign := make(chan byte, 1)</span><br><span class="line"></span><br><span class="line">    //给ch11通道写入数据</span><br><span class="line">    for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">        ch11 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单独起一个Goroutine执行select</span><br><span class="line">    go func()&#123;</span><br><span class="line">        var e int</span><br><span class="line">        ok := true</span><br><span class="line">        //首先声明一个*time.Timer类型的值，然后在相关case之后声明的匿名函数中尽可能的复用它</span><br><span class="line">        var timer *time.Timer</span><br><span class="line"></span><br><span class="line">        for&#123;</span><br><span class="line">            select &#123;</span><br><span class="line">                case e = &lt;- ch11:</span><br><span class="line">                    fmt.Printf(&quot;ch11 -&gt; %d\n&quot;,e)</span><br><span class="line">                case &lt;- func() &lt;-chan time.Time &#123;</span><br><span class="line">                    if timer == nil&#123;</span><br><span class="line">                        //初始化到期时间据此间隔1ms的定时器</span><br><span class="line">                        timer = time.NewTimer(time.Millisecond)</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        //复用，通过Reset方法重置定时器</span><br><span class="line">                        timer.Reset(time.Millisecond)</span><br><span class="line">                    &#125;</span><br><span class="line">                    //得知定时器到期事件来临时，返回结果</span><br><span class="line">                    return timer.C</span><br><span class="line">                &#125;():</span><br><span class="line">                    fmt.Println(&quot;Timeout.&quot;)</span><br><span class="line">                    ok = false</span><br><span class="line">                    break</span><br><span class="line">            &#125;</span><br><span class="line">            //终止for循环</span><br><span class="line">            if !ok &#123;</span><br><span class="line">                sign &lt;- 0</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    //惯用手法，读取sign通道数据，为了等待select的Goroutine执行。</span><br><span class="line">    &lt;- sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="time-After函数"><a href="#time-After函数" class="headerlink" title="time.After函数"></a>time.After函数</h2><p>time.After函数</p><ul><li><p>表示多少时间之后，但是在取出channel内容之前不阻塞，后续程序可以继续执行</p></li><li><p>鉴于After特性，其通常用来处理程序超时问题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    ch1 := make(chan int, 1)</span><br><span class="line">    ch2 := make(chan int, 1)</span><br><span class="line"></span><br><span class="line">    select &#123;</span><br><span class="line">        case e1 := &lt;-ch1:</span><br><span class="line">        //如果ch1通道成功读取数据，则执行该case处理语句</span><br><span class="line">            fmt.Printf(&quot;1th case is selected. e1=%v&quot;,e1)</span><br><span class="line">        case e2 := &lt;-ch2:</span><br><span class="line">        //如果ch2通道成功读取数据，则执行该case处理语句</span><br><span class="line">            fmt.Printf(&quot;2th case is selected. e2=%v&quot;,e2)</span><br><span class="line">        case &lt;- time.After(2 * time.Second):</span><br><span class="line">            fmt.Println(&quot;Timed out&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="golang打印结构体"><a href="#golang打印结构体" class="headerlink" title="golang打印结构体"></a>golang打印结构体</h3><p>如果使用fmt.println（v）<br>打印的结果往往令人迷惑，要想看到结构体内部的数据可以使用<br><code>fmt.printf(&quot;+v&quot;,v)</code></p><p><strong>如果需要打印的内容是一个<code>[]</code>byte</strong></p><p>那么使用 fmt.printf(“%s”,v)<br>就可以把这个切片字节的字符串打印出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初始化一个定时器&quot;&gt;&lt;a href=&quot;#初始化一个定时器&quot; class=&quot;headerlink&quot; title=&quot;初始化一个定时器&quot;&gt;&lt;/a&gt;初始化一个定时器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/digest/batu-g
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="golang" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/golang/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>docker file中使用多个FROM</title>
    <link href="http://yoursite.com/2019/10/20/docker-multi-from/"/>
    <id>http://yoursite.com/2019/10/20/docker-multi-from/</id>
    <published>2019-10-20T09:17:18.000Z</published>
    <updated>2019-11-03T13:12:48.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="能否使用多个FROM"><a href="#能否使用多个FROM" class="headerlink" title="能否使用多个FROM?"></a>能否使用多个FROM?</h2><p>在使用docker过程中，dockerhub上的docker镜像往往已经能够满足需求，<br>然鹅，需求是无止境的。有时候我们需要特殊定制一些镜像。我们需要A镜像中的一些文件,以及B镜像中的另外一些文件，以及….</p><a id="more"></a><h2 id="多个-FROM-指令的意义"><a href="#多个-FROM-指令的意义" class="headerlink" title="多个 FROM 指令的意义"></a>多个 FROM 指令的意义</h2><p>多个 FROM 指令并不是为了生成多根的层关系，最后生成的镜像，仍以最后一条 FROM 为准，之前的 FROM 会被抛弃，那么之前的FROM 又有什么意义呢？</p><p>每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。</p><h2 id="构造器模式是什么？"><a href="#构造器模式是什么？" class="headerlink" title="构造器模式是什么？"></a>构造器模式是什么？</h2><p>对于像Golang这样的静态编译语言，人们倾向于从Golang“ SDK”映像中获取其Dockerfile，添加源代码，进行构建，然后将其推送到Docker Hub。但是生成的镜像的大小至少为670M。</p><p>一种非官方的构造器模式(<strong>builder pattern</strong>) 的解决方法是使用两个Docker映像-一个用于执行构建，另一个用于发送第一个构建的结果，而不会破坏第一个映像中的构建链和工具。<br>Golang并不是唯一可以通过使用一个基础映像来构建资产并使用第二个映像来运行资产而受益的语言。<br>在Windows容器中的工作也使用此模式来生成较小的图像。</p><p>builder pattern的示例：</p><ol><li>从Golang基本映像派生整个运行时/ SDK（Dockerfile.build）</li><li>添加源代码</li><li>产生一个静态链接的二进制文件</li><li>将静态二进制文件从镜像复制到主机（docker create，docker cp）</li><li>从<code>SCRATCH</code>或其他轻量级映像分离，例如<code>alpine</code>（Dockerfile）</li><li>重新添加二进制文件</li><li>将这个很小的映像推送到Docker Hub</li></ol><p>这意味着要有两个单独的Dockerfile和一个Shell脚本来编排以上所有7个步骤。</p><p>以一个golang的项目为例：</p><p>Dockerfile.build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>build.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo Building alexellis2/href-counter:build</span><br><span class="line"></span><br><span class="line">docker build --build-arg https_proxy=$https_proxy --build-arg http_proxy=$http_proxy \</span><br><span class="line">    -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract alexellis2/href-counter:build </span><br><span class="line">docker cp extract:/go/src/github.com/alexellis/href-counter/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building alexellis2/href-counter:latest</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><h2 id="什么是多阶段构建？"><a href="#什么是多阶段构建？" class="headerlink" title="什么是多阶段构建？"></a>什么是多阶段构建？</h2><p>多阶段构建具有构建器模式的优点，而无需维护三个单独的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>但是，对于开发者和维护者来说，这仍然很大，特别是使用树莓派的用户。<br>在Dockerfile中使用多个FROM-以最后一条FROM语句为最终基础映像为准<br>。要复制中间图像的伪像和输出，<br>请使用<code>COPY --from=镜像号码</code></p><p>改进后的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line"></span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go.</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line"></span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app    .</span><br><span class="line"></span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p>有些程序要么没有apt源，要么apt源中的版本太老，<br>要么干脆只提供源码需要自己编译，使用这些程序时，<br>我们可以方便地使用已经存在的Docker镜像源作为我们的基础镜像。<br>但是我们的软件有时候可能需要依赖多个这种文件，<br>我们并不能同时将 nginx 和 etcd 的镜像同时作为我们的基础镜像<br>（不支持多根），这种情况下，使用 COPY –from 就非常方便实用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;能否使用多个FROM&quot;&gt;&lt;a href=&quot;#能否使用多个FROM&quot; class=&quot;headerlink&quot; title=&quot;能否使用多个FROM?&quot;&gt;&lt;/a&gt;能否使用多个FROM?&lt;/h2&gt;&lt;p&gt;在使用docker过程中，dockerhub上的docker镜像往往已经能够满足需求，&lt;br&gt;然鹅，需求是无止境的。有时候我们需要特殊定制一些镜像。我们需要A镜像中的一些文件,以及B镜像中的另外一些文件，以及….&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>moviepy 中文镜像</title>
    <link href="http://yoursite.com/2019/10/20/moviepy-docker/"/>
    <id>http://yoursite.com/2019/10/20/moviepy-docker/</id>
    <published>2019-10-20T09:17:18.000Z</published>
    <updated>2019-11-04T17:15:57.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先是系统的环境问题。"><a href="#首先是系统的环境问题。" class="headerlink" title="首先是系统的环境问题。"></a>首先是系统的环境问题。</h2><p>linux 安装 moviepy需要很多依赖，安装起来费神费力。配置起来也非常麻烦，最简单的办法是直接使用他人构建好的镜像文件。</p><a id="more"></a><h2 id="再就是字体显示问题。"><a href="#再就是字体显示问题。" class="headerlink" title="再就是字体显示问题。"></a>再就是字体显示问题。</h2><p>镜像中的imagmagick不支持中文的字体。生成的视频中文乱码，搜索了好!</p><p>长时间，决定自己手动构建一个镜像。参考的文章链接：</p><p><a href="https://www.cnblogs.com/dunkbird/p/5623209.html" target="_blank" rel="noopener">linux追加中文字库，解决imagemagick 中文乱码的问题</a></p><p><a href="https://blog.csdn.net/soulmate_P/article/details/8785642" target="_blank" rel="noopener">Linux(Ubuntu，Cent OS)环境安装mkfontscale mkfontdir命令以及中文字库</a></p><p>步骤简单分为几步：</p><ul><li>拷贝本地Windows下的font（选择你想要的）到镜像中。</li><li>镜像安装构建字体的依赖</li><li>构建字体文件夹</li><li>build 镜像</li></ul><p>放一下Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM dkarchmervue/moviepy:latest</span><br><span class="line"># 我在同级目录下创建了一个windows_fonts文件夹，里面放着从window下拷贝过来的文件。考本到镜像的字体文件夹下。</span><br><span class="line">COPY ./wondow_fonts/ /usr/share/fonts/windows/</span><br><span class="line"># 更改ubuntu镜像源，dkarchmervue/moviepy是基于ubuntu14.04，找一个镜像源，在本地创建一个sources.list的文件，拷贝到镜像中就可以。</span><br><span class="line">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">COPY sources.list /etc/apt/sources.list </span><br><span class="line">RUN apt-get update</span><br><span class="line"># 安装添加字体的依赖</span><br><span class="line">RUN apt-get install ttf-mscorefonts-installer -y &amp;&amp; apt-get install fontconfig -y\</span><br><span class="line">     &amp;&amp; apt-get install fontconfig \</span><br><span class="line">    &amp;&amp; cd /usr/share/fonts/windows/ &amp;&amp; chmod 777 * &amp;&amp; mkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache</span><br><span class="line">WORKDIR /work/</span><br></pre></td></tr></table></figure><p>这样就制作了一个基于<code>dkarchmervue/moviepy</code> 的带中文字体的镜像。<br>然后直接运行 <code>docker build -t moviepy_cnfonts .</code> 即可创建一个名为 moviepy_cnfonts的镜像。可以把这个镜像替代<code>dkarchmervue/moviepy:latest</code>这个镜像作为运行 python文件的基础镜像。</p><p>运行moviepy官方的结尾特效 end_effect</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1200357-20190919202017204-216254823.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;首先是系统的环境问题。&quot;&gt;&lt;a href=&quot;#首先是系统的环境问题。&quot; class=&quot;headerlink&quot; title=&quot;首先是系统的环境问题。&quot;&gt;&lt;/a&gt;首先是系统的环境问题。&lt;/h2&gt;&lt;p&gt;linux 安装 moviepy需要很多依赖，安装起来费神费力。配置起来也非常麻烦，最简单的办法是直接使用他人构建好的镜像文件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="moviepy" scheme="http://yoursite.com/tags/moviepy/"/>
    
  </entry>
  
  <entry>
    <title>python-cache</title>
    <link href="http://yoursite.com/2019/10/03/python-cache/"/>
    <id>http://yoursite.com/2019/10/03/python-cache/</id>
    <published>2019-10-03T04:42:40.000Z</published>
    <updated>2019-11-04T17:15:57.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="msgpack介绍"><a href="#msgpack介绍" class="headerlink" title="msgpack介绍"></a>msgpack介绍</h2><p>在阅读sanic相关项目的时候 <a href=""https://github.com/howie6879/Sanic-For-Pythoneer/blob/master/docs/part1/6.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7.md"">Sanic-For-Pythoneer</a> 阅读代码过程中发现几个比较好用的python库，</p><h3 id="1-cached"><a href="#1-cached" class="headerlink" title="1. cached"></a>1. cached</h3><p>缓存其实应用场景还是比较多的。比如我现在应用的就是对 从database中获取到的数据做缓存，设置ttl(time to live)以减小数据库压力。</p><a id="more"></a><p>cached的简单应用 （python = 3.7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import aiocache</span><br><span class="line">from aiocache.serializers import NullSerializer, StringSerializer, \</span><br><span class="line">    PickleSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@aiocache.cached(ttl=10, serializer=PickleSerializer())</span><br><span class="line">async def get_res():</span><br><span class="line">    print(&quot;get_res(): int(11)&quot;)</span><br><span class="line">    return 11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import asyncio</span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    data = asyncio.run(get_res())</span><br><span class="line">    print(type(data), data)</span><br><span class="line">    data = asyncio.run(get_res())</span><br><span class="line">    print(type(data), data)</span><br></pre></td></tr></table></figure><p>aiocache实现并不复杂。介绍一下 SimpleMemoryCache。大致的思路就是 把数据保存到字典中，key默认为 model_name+ func_name + args + kwargs 组合（可以指定key的值），到了ttl设定的时间就把map中的键值pop出去。<br>其他的也是类似的思路。</p><p>这里值得注意的是 <code>serializer</code>这个参数。如果是使用 <code>SimpleMemoryCache</code>作为缓存，默认是使用 <code>NullSerializer</code>作为序列化工具的，即set的任何内容都可以在get时原样获取，在本地内存中这一点问题没有。<br>如果需要对对象序列化 建议使用 <code>PickleSerializer</code><br><a href=""https://www.zhihu.com/question/38355589"">我是pickle</a></p><p>但是如果使用redis作为缓存，会发生一些预测不到的错误。解决办法是使用：<code>JsonSerializer</code>,内部使用的是 <code>ujson</code>作为序列化工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json module and ujson:</span><br><span class="line">        - ujson dumps supports bytes while json doesn&apos;t</span><br><span class="line">        - ujson and json outputs may differ sometimes</span><br></pre></td></tr></table></figure><p>还有一个 <code>MsgPackSerializer</code>,</p><p><code>Transform data to bytes using msgpack.dumps and msgpack.loads to retrieve it back.</code></p><p>还有一个序列化参数，用的比较少，<code>StringSerializer</code>,比如你缓存的是 1，在下次获取缓存结果的时候会给你返回 <code>&#39;1&#39;</code>。</p><h3 id="2-msgpack"><a href="#2-msgpack" class="headerlink" title="2. msgpack"></a>2. msgpack</h3><p>msgpack 是cached包安装时候的依赖。进入源码，发现其对外提供的API非常简单，用法与 ujson,json 等序列/反序列工具基本一直。</p><p>其源码中对外暴露方法做了常规化处理，这样我们用起来很快适应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># alias for compatibility to simplejson/marshal/pickle.</span><br><span class="line">load = unpack</span><br><span class="line">loads = unpackb</span><br><span class="line"></span><br><span class="line">dump = pack</span><br><span class="line">dumps = packb</span><br></pre></td></tr></table></figure><p>msgpack的优势是：msgpack用起来像json，但是却比json快，并且序列化以后的数据长度更小，言外之意，使用msgpack不仅序列化和反序列化的速度快，数据传输量也比json格式小，msgpack同样支持多种语言。</p><p>我们平时主要会用到 <code>loads</code> 等同于 <code>unpackb</code> , <code>dumps</code> 等同于 <code>packb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import msgpack</span><br><span class="line">&gt;&gt;&gt;animal = &#123;&quot;color&quot;:&quot;pink&quot;,&quot;name&quot;:&quot;duck&quot;&#125;</span><br><span class="line">&gt;&gt;&gt;msgpack.dumps(animal) // 比 json.dumps(x)的长度更小</span><br><span class="line">b&apos;\x82\xa5color\xa4pink\xa4name\xa4duck&apos;</span><br><span class="line">&gt;&gt;&gt;msgpack.loads(msgpack.dumps(animal))</span><br><span class="line">&#123;b&apos;color&apos;: b&apos;pink&apos;, b&apos;name&apos;: b&apos;duck&apos;&#125;</span><br><span class="line">&gt;&gt;&gt;msgpack.loads(msgpack.dumps(animal),encoding=&quot;utf-8&quot;) // 转会初始状态的字符串，需要加上 encoding这个参数，内部会调用decode()方法</span><br><span class="line">&#123;&apos;color&apos;: &apos;pink&apos;, &apos;name&apos;: &apos;duck&apos;&#125;</span><br></pre></td></tr></table></figure><p>另外 load 和 dump的用法和json.load &amp; json.dump用法相同。<br>该包源码非常简单，有兴趣的可以去看看源码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;msgpack介绍&quot;&gt;&lt;a href=&quot;#msgpack介绍&quot; class=&quot;headerlink&quot; title=&quot;msgpack介绍&quot;&gt;&lt;/a&gt;msgpack介绍&lt;/h2&gt;&lt;p&gt;在阅读sanic相关项目的时候 &lt;a href=&quot;&quot;https://github.com/howie6879/Sanic-For-Pythoneer/blob/master/docs/part1/6.%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E5%B7%A7.md&quot;&quot;&gt;Sanic-For-Pythoneer&lt;/a&gt; 阅读代码过程中发现几个比较好用的python库，&lt;/p&gt;
&lt;h3 id=&quot;1-cached&quot;&gt;&lt;a href=&quot;#1-cached&quot; class=&quot;headerlink&quot; title=&quot;1. cached&quot;&gt;&lt;/a&gt;1. cached&lt;/h3&gt;&lt;p&gt;缓存其实应用场景还是比较多的。比如我现在应用的就是对 从database中获取到的数据做缓存，设置ttl(time to live)以减小数据库压力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>flask.run()不是你的服务器！</title>
    <link href="http://yoursite.com/2019/09/23/flask-is-not-production-server/"/>
    <id>http://yoursite.com/2019/09/23/flask-is-not-production-server/</id>
    <published>2019-09-23T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不要再用flask-run-部署项目了！"><a href="#不要再用flask-run-部署项目了！" class="headerlink" title="不要再用flask.run()部署项目了！"></a>不要再用flask.run()部署项目了！</h3><p>在维护公司老项目,服务器查看运行着一个flask项目。用简单的单进程跑在机器上。<br>查看详细的信息，发现是直接用这种方式运行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def route1():</span><br><span class="line">   pass</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(....)</span><br></pre></td></tr></table></figure><a id="more"></a><dl><dt>这种方式真的很不好，稍微看一下docs就能看到flask已经给了很明显的警高信息</dt><dd><code>WARNING: This is a development server. Do not use it in a production deployment.</code></dd></dl><h3 id="下面就来讲一讲为何不好-："><a href="#下面就来讲一讲为何不好-：" class="headerlink" title="下面就来讲一讲为何不好 ："></a><strong>下面就来讲一讲为何不好</strong> ：</h3><p>你已经构建了Flask网络应用，并正在部署自己选择的VPS上。这是你的第一个小型应用程序，你希望将app.run上的debug设置为False就足够了？也许也启用线程？</p><p>你真的不应该依赖于此。官方文档也不同意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">While lightweight and easy to use, Flask’s built-in server is </span><br><span class="line">not suitable for production as it doesn’t scale well </span><br><span class="line">and by default serves only one request at a time.</span><br></pre></td></tr></table></figure><p>现在怎么办？好吧，不要混为一谈。一切都很好，你只需要了解Flask部署Web服务器的用途，缺少的什么以及拿什么东西顶上就好了。</p><h4 id="Flask的内置Web服务器"><a href="#Flask的内置Web服务器" class="headerlink" title="Flask的内置Web服务器"></a>Flask的内置Web服务器</h4><p>Flask提供的内置 Web服务器是为了方便开发。</p><p>有了它，你就可以在本地计算机上访问你的应用程序，而无需开启其他服务并让它们协调工作。但是，它只能一次由一个人使用，<br>它就是以这种方式构建的–<strong>就是为了方便你开发</strong>。它也可以提供静态文件，但是与为快速处理文件而设计的工具(如nginx)相比，<br>这样做的速度非常慢。当只有一个人访问它时，这无关紧要，只要达到开发调试的目的就可以了。</p><p>在生产环境中运行Web应用程序时，我们希望它能够处理多个用户的过个请求，而那些使用我们服务的人不必为加载页面和静态文件焦急等待。</p><h4 id="生产栈结构"><a href="#生产栈结构" class="headerlink" title="生产栈结构"></a>生产栈结构</h4><p>生产环境的设置通常由多个组件组成，每个组件的设计和构建都非常擅长于同一件事–快速，可靠，专注。</p><p>就像内置Web服务器一样，与整个设备的通信都是通过HTTP进行的。一个请求进入并到达第一个组件-专用的Web服务器。<br>它非常适合从磁盘读取静态文件（例如，你的css，js文件）并处理多个请求。当请求不是静态文件时，<br>所有请求都将传递到堆栈中。</p><p>应用程序服务器获取这些的请求，并将这些请求中的信息转换为框架可以使用的Python对象-WSGI。</p><p>Flask应用实际上并未像我们想象的作为服务器等待请求并对它们做出反应。<br>而是可以被认为是被应用服务器作为方法调用，提供请求对象。</p><p>然后，应用程序服务器将运行应用程序的输出打包到HTTP响应中，并传递回Web服务器，再传递回给用户。</p><p>意思是<br>如果要在生产环境中运行Flask，请确保使用可用于生产环境的Web服务器，例如Nginx，并让你的应用程序由WSGI应用程序服务器（例如Gunicorn）处理。</p><p>完毕！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不要再用flask-run-部署项目了！&quot;&gt;&lt;a href=&quot;#不要再用flask-run-部署项目了！&quot; class=&quot;headerlink&quot; title=&quot;不要再用flask.run()部署项目了！&quot;&gt;&lt;/a&gt;不要再用flask.run()部署项目了！&lt;/h3&gt;&lt;p&gt;在维护公司老项目,服务器查看运行着一个flask项目。用简单的单进程跑在机器上。&lt;br&gt;查看详细的信息，发现是直接用这种方式运行的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@app.route(&amp;apos;/&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def route1():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   pass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run(....)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>flask应用上下文和请求上下文</title>
    <link href="http://yoursite.com/2019/09/23/flask%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87&amp;%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://yoursite.com/2019/09/23/flask应用上下文&amp;请求上下文/</id>
    <published>2019-09-23T13:47:23.000Z</published>
    <updated>2019-11-04T17:15:57.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flask应用上下文和请求上下文"><a href="#flask应用上下文和请求上下文" class="headerlink" title="flask应用上下文和请求上下文"></a>flask应用上下文和请求上下文</h2><p>虽然现在已经是python3的时代，一些开发库已经不支持python2并且asyncio也越来越多的被应用。<br>但是个人感觉如果要解决高并发问题，使用asyncio并不是很好的实践。</p><a id="more"></a><p>因为协程之间并不是简单的调用切换，还涉及到一些协程间通信。<br>使用python还是以‘顺序’编程为主，如果公司对高并发真的是有急迫的需求，更好的选择应该是<code>golang</code></p><p>与<code>flask</code>对应的异步web框架是<code>sanic</code>。两者的编程风格很相似，包括核心app的构建方法，路由等。<br><code>sanic</code>是基于asyncio的事件回调机制来完成的，与tornado（老版的tornado是基于yield实现的类似于协程的切换）相比，性能及可读性更高一些。</p><p>我个人实际开发中对并发并没有很高的要求，所以应用最多的还是flask，原因很简单-需求驱动。</p><p>简单整理了flask的应用上下文和请求上下文的处理过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flask.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flask应用上下文和请求上下文&quot;&gt;&lt;a href=&quot;#flask应用上下文和请求上下文&quot; class=&quot;headerlink&quot; title=&quot;flask应用上下文和请求上下文&quot;&gt;&lt;/a&gt;flask应用上下文和请求上下文&lt;/h2&gt;&lt;p&gt;虽然现在已经是python3的时代，一些开发库已经不支持python2并且asyncio也越来越多的被应用。&lt;br&gt;但是个人感觉如果要解决高并发问题，使用asyncio并不是很好的实践。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch－基础介绍及索引原理分析</title>
    <link href="http://yoursite.com/2019/09/13/elaskticsearch/"/>
    <id>http://yoursite.com/2019/09/13/elaskticsearch/</id>
    <published>2019-09-13T13:47:23.000Z</published>
    <updated>2019-11-03T08:29:42.514Z</updated>
    
    <content type="html"><![CDATA[<p>#Elasticsearch－基础介绍及索引原理分析</p><p>最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。</p><a id="more"></a><p>##介绍<br>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p><ul><li><p>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</p></li><li><p>实时分析的分布式搜索引擎。</p></li><li><p>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</p></li></ul><p>##基本概念<br>先说Elasticsearch的文件存储，Elasticsearch是面向文档型数据库，一条数据在这里就是一个文档，用JSON作为文档序列化的格式，比如下面这条用户数据：</p><p>{<br>“name” : “John”,<br>“sex” : “Male”,<br>“age” : 25,<br>“birthDate”: “1990/05/01”,<br>“about” : “I love to go rock climbing”,<br>“interests”: [ “sports”, “music” ]<br>}<br>用Mysql这样的数据库存储就会容易想到建立一张User表，有balabala的字段等，在Elasticsearch里这就是一个文档，当然这个文档会属于一个User的类型，各种各样的类型存在于一个索引当中。这里有一份简易的将Elasticsearch和关系型数据术语对照表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关系数据库 ⇒ 数据库 ⇒ 表 ⇒ 行 ⇒ 列(Columns)</span><br><span class="line"></span><br><span class="line">Elasticsearch ⇒ 索引(Index) ⇒ 类型(type) ⇒ 文档(Docments) ⇒ 字段(Fields)</span><br></pre></td></tr></table></figure><p>一个 Elasticsearch 集群可以包含多个索引(数据库)，也就是说其中包含了很多类型(表)。这些类型中包含了很多的文档(行)，然后每个文档中又包含了很多的字段(列)。Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式，比如我们打算插入一条记录，可以简单发送一个HTTP的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot; : &quot;John&quot;,</span><br><span class="line">&quot;sex&quot; : &quot;Male&quot;,</span><br><span class="line">&quot;age&quot; : 25,</span><br><span class="line">&quot;about&quot; : &quot;I love to go rock climbing&quot;,</span><br><span class="line">&quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新，查询也是类似这样的操作，具体操作手册可以参见Elasticsearch权威指南</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Elasticsearch最关键的就是提供强大的索引能力了，其实InfoQ的这篇时间序列数据库的秘密(2)——索引写的非常好，我这里也是围绕这篇结合自己的理解进一步梳理下，也希望可以帮助大家更好的理解这篇文章。<br>Elasticsearch索引的精髓：</p><blockquote><p>一切设计都是为了提高搜索的性能</p></blockquote><p>另一层意思：为了提高搜索的性能，难免会牺牲某些其他方面，比如插入/更新，否则其他数据库不用混了。前面看到往Elasticsearch里插入一条记录，其实就是直接PUT一个json的对象，这个对象有多个fields，比如上面例子中的name, sex, age, about, interests，那么在插入这些数据到Elasticsearch的同时，Elasticsearch还默默1的为这些字段建立索引–倒排索引，因为Elasticsearch最核心功能是搜索。<br>###Elasticsearch是如何做到快速索引的<br>InfoQ那篇文章里说Elasticsearch使用的倒排索引比关系型数据库的B-Tree索引快，为什么呢？<br>###什么是B-Tree索引?<br>上大学读书时老师教过我们，二叉树查找效率是logN，同时插入新的节点不必移动全部节点，<br>所以用树型结构存储索引，能同时兼顾插入和查询的性能。因此在这个基础上，<br>再结合磁盘的读取特性(顺序读/随机读)，传统关系型数据库采用了B-Tree/B+Tree这样的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/b-tree.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了提高查询的效率，减少磁盘寻道次数，将多个值作为一个数组通过连续区间存放，<br>一次寻道读取多个数据，同时也降低树的高度。<br>###什么是倒排索引?</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/inverted-index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>继续上面的例子，假设有这么几条数据(为了简单，去掉about, interests这两个field):</p><table><thead><tr><th>ID</th><th align="center">Name</th><th align="right">Age</th><th align="right">Sex</th></tr></thead><tbody><tr><td>1</td><td align="center">Kate</td><td align="right">24</td><td align="right">Female</td></tr><tr><td>2</td><td align="center">John</td><td align="right">24</td><td align="right">Male</td></tr><tr><td>3</td><td align="center">Bill</td><td align="right">29</td><td align="right">Male</td></tr></tbody></table><p>ID是Elasticsearch自建的文档id，那么Elasticsearch建立的索引如下:<br>Name:</p><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Kate</td><td align="center">1</td></tr><tr><td>John</td><td align="center">2</td></tr><tr><td>Bill</td><td align="center">3</td></tr><tr><td>Age:</td><td align="center"></td></tr></tbody></table><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>24</td><td align="center">[1,2]</td></tr><tr><td>29</td><td align="center">3</td></tr><tr><td>Sex:</td><td align="center"></td></tr></tbody></table><table><thead><tr><th>Term</th><th align="center">Posting List</th></tr></thead><tbody><tr><td>Female</td><td align="center">1</td></tr><tr><td>Male</td><td align="center">[2,3]</td></tr></tbody></table><ul><li>Posting List</li></ul><p>Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而[1,2]就是Posting List。Posting list就是一个int的数组，存储了所有符合某个term的文档id。<br>看到这里，不要认为就结束了，精彩的部分才刚开始…<br>通过posting list这种索引方式似乎可以很快进行查找，比如要找age=24的同学，爱回答问题的小明马上就举手回答：我知道，id是1，2的同学。但是，如果这里有上千万的记录呢？如果是想通过name来查找呢？</p><ul><li>Term Dictionary</li></ul><p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。现在再看起来，似乎和传统数据库通过B-Tree的方式类似啊，为什么说比B-Tree的查询快呢？</p><ul><li>Term Index</li></ul><p>B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过内存查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理解term index是一颗树：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/term-index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/index.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。<br>这时候爱提问的小明又举手了:”那个FST是神马东东啊?”<br>一看就知道小明是一个上大学读书的时候跟我一样不认真听课的孩子，<br>数据结构老师一定讲过什么是FST。但没办法，我也忘了，这里再补下课：</p><blockquote><p>FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output.</p></blockquote><p>假设我们现在要将mop, moth, pop, star, stop and top(term index里的term前缀)映射到序号：0，1，2，3，4，5(term dictionary的block位置)。最简单的做法就是定义个Map&lt;string, integer=””&gt;，大家找到自己的位置对应入座就好了，但从内存占用少的角度想想，有没有更优的办法呢？答案就是：FST(<a href="http://www.cs.nyu.edu/~mohri/pub/fla.pdf" target="_blank" rel="noopener">理论依据在此，但我相信99%的人不会认真看完的</a>)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/fst.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>⭕️表示一种状态<br>–&gt;表示状态的变化过程，上面的字母/数字表示状态变化和权重<br>将单词分成单个字母通过⭕️和–&gt;表示出来，0权重不显示。如果⭕️后面出现分支，就标记权重，最后整条路径上的权重加起来就是这个单词对应的序号。<br><code>FSTs are finite-state machines that map a term (byte sequence) to an arbitrary output.</code></p><p>FST以字节的方式存储所有的term，这种压缩方式可以有效的缩减存储空间，使得term index足以放进内存，但这种方式也会导致查找时需要更多的CPU资源。<br>后面的更精彩，看累了的同学可以喝杯咖啡……</p><h3 id="压缩技巧"><a href="#压缩技巧" class="headerlink" title="压缩技巧"></a>压缩技巧</h3><p>Elasticsearch里除了上面说到用FST压缩term index外，对posting list也有压缩技巧。<br>小明喝完咖啡又举手了:”posting list不是已经只存储文档id了吗？还需要压缩？”<br>嗯，我们再看回最开始的例子，如果Elasticsearch需要对同学的性别进行索引(这时传统关系型数据库已经哭晕在厕所……)，会怎样？如果有上千万个同学，而世界上只有男/女这样两个性别，每个posting list都会有至少百万个文档id。<br>Elasticsearch是如何有效的对这些文档id压缩的呢？</p><ul><li>Frame Of Reference</li></ul><blockquote><p>增量编码压缩，将大数变小数，按字节存储</p></blockquote><p>首先，Elasticsearch要求posting list是有序的(为了提高搜索的性能，再任性的要求也得满足)，这样做的一个好处是方便压缩，看下面这个图例：</p><p><img src="/images/frameOfReference.png" alt=""><br>如果数学不是体育老师教的话，还是比较容易看出来这种压缩技巧的。<br>原理就是通过增量，将原来的大数变成小数仅存储增量值，再精打细算按bit排好队，最后通过字节存储，而不是大大咧咧的尽管是2也是用int(4个字节)来存储。<br><strong>Roaring bitmaps</strong></p><p>说到Roaring bitmaps，就必须先从bitmap说起。Bitmap是一种数据结构，假设有某个posting list：<br><code>[1,3,4,7,10]</code><br>对应的bitmap就是：<br><code>[1,0,1,1,0,0,1,0,0,1]</code><br>非常直观，用0/1表示某个值是否存在，比如10这个值就对应第10位，对应的bit值是1，这样用一个字节就可以代表8个文档id，旧版本(5.0之前)的Lucene就是用这样的方式来压缩的，但这样的压缩方式仍然不够高效，如果有1亿个文档，那么需要12.5MB的存储空间，这仅仅是对应一个索引字段(我们往往会有很多个索引字段)。于是有人想出了Roaring bitmaps这样更高效的数据结构。<br>Bitmap的缺点是存储空间随着文档个数线性增长，Roaring bitmaps需要打破这个魔咒就一定要用到某些指数特性：<br>将posting list按照65535为界限分块，比如第一块所包含的文档id范围在0<del>65535之间，第二块的id范围是65536</del>131071，以此类推。再用&lt;商，余数&gt;的组合表示每一组id，这样每组里的id范围都在0~65535内了，剩下的就好办了，既然每组id不会变得无限大，那么我们就可以通过最有效的方式对这里的id存储。</p><p>细心的小明这时候又举手了:”为什么是以65535为界限?”<br>程序员的世界里除了1024外，65535也是一个经典值，因为它=2^16-1，正好是用2个字节能表示的最大数，一个short的存储单位，注意到上图里的最后一行“If a block has more than 4096 values, encode as a bit set, and otherwise as a simple array using 2 bytes per value”，如果是大块，用节省点用bitset存，小块就豪爽点，2个字节我也不计较了，用一个short[]存着方便。<br>那为什么用4096来区分大块还是小块呢？<br>个人理解：都说程序员的世界是二进制的，4096*2bytes ＝ 8192bytes &lt; 1KB, 磁盘一次寻道可以顺序把一个小块的内容都读出来，再大一位就超过1KB了，需要两次读。</p><ul><li><strong>联合索引</strong></li></ul><p>上面说了半天都是单field索引，如果多个field索引的联合查询，倒排索引如何满足快速查询的要求呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 利用跳表(Skip list)的数据结构快速做“与”运算，或者</span><br><span class="line"></span><br><span class="line">- 利用上面提到的bitset按位“与”</span><br></pre></td></tr></table></figure><p>先看看跳表的数据结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/skiplist.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>将一个有序链表level0，挑出其中几个元素到level1及level2，每个level越往上，选出来的指针元素越少，查找时依次从高level往低查找，比如55，先找到level2的31，再找到level1的47，最后找到55，一共3次查找，查找效率和2叉树的效率相当，但也是用了一定的空间冗余来换取的。<br>假设有下面三个posting list需要联合索引：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/combineIndex.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果使用跳表，对最短的posting list中的每个id，逐个在另外两个posting list中查找看是否存在，最后得到交集的结果。<br>如果使用bitset，就很直观了，直接按位与，得到的结果就是最后的交集。总结和思考<br>Elasticsearch的索引思路:</p><blockquote><p>将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。</p></blockquote><p>所以，对于使用Elasticsearch进行索引时需要注意:</p><ul><li><p>不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的</p></li><li><p>同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的</p></li><li><p>选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询</p></li></ul><p>关于最后一点，个人认为有多个因素:<br>其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高；<br>另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数，具体可以参考这篇如何选择一个高效的全局ID方案(评论也很精彩)</p><p>转自神一般的存在，<a href="http://blog.pengqiuyuan.com/ji-chu-jie-shao-ji-suo-yin-yuan-li-fen-xi/" target="_blank" rel="noopener">文章链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Elasticsearch－基础介绍及索引原理分析&lt;/p&gt;
&lt;p&gt;最近在参与一个基于Elasticsearch作为底层数据框架提供大数据量(亿级)的实时统计查询的方案设计工作，花了些时间学习Elasticsearch的基础理论知识，整理了一下，希望能对Elasticsearch感兴趣/想了解的同学有所帮助。 同时也希望有发现内容不正确或者有疑问的地方，望指明，一起探讨，学习，进步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>实现tornado login_required()</title>
    <link href="http://yoursite.com/2019/08/01/tornado-login-required/"/>
    <id>http://yoursite.com/2019/08/01/tornado-login-required/</id>
    <published>2019-08-01T06:20:20.000Z</published>
    <updated>2019-11-04T17:15:57.581Z</updated>
    
    <content type="html"><![CDATA[<p>tornado作为鼎鼎大名的web异步框架，用来作为高性能服务器以及web框架都是首选。自从python3.4加入了asyncio原生协程后，tornado的最新版本也开始使用了原生的协程。定义协程函数的时候就很简单了，也可以像sanic一样使用async def了。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LoginHandler(RequestHandler):</span><br><span class="line">    async def post(self, *args, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>一般的web项目都会有登陆的功能，这就涉及到了登陆验证，在做这一部分功能的时候，我使用的是 jwt – json web token的方法验证是否登陆。当然也可以使用类似于django的session验证。各自均有优缺点。</p><p>通常需要验证是否登陆的模块很多，一般都会写一个登陆验证装饰器，tornado实现了登陆验证装饰器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def authenticated(method):</span><br><span class="line">    &quot;&quot;&quot;Decorate methods with this to require that the user be logged in.</span><br><span class="line"></span><br><span class="line">    If the user is not logged in, they will be redirected to the configured</span><br><span class="line">    `login url &lt;RequestHandler.get_login_url&gt;`.</span><br><span class="line"></span><br><span class="line">    If you configure a login url with a query parameter, Tornado will</span><br><span class="line">    assume you know what you&apos;re doing and use it as-is.  If not, it</span><br><span class="line">    will add a `next` parameter so the login page knows where to send</span><br><span class="line">    you once you&apos;re logged in.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    @functools.wraps(method)</span><br><span class="line">    def wrapper(self, *args, **kwargs):</span><br><span class="line">        if not self.current_user:</span><br><span class="line">            if self.request.method in (&quot;GET&quot;, &quot;HEAD&quot;):</span><br><span class="line">                url = self.get_login_url()</span><br><span class="line">                if &quot;?&quot; not in url:</span><br><span class="line">                    if urlparse.urlsplit(url).scheme:</span><br><span class="line">                        # if login url is absolute, make next absolute too</span><br><span class="line">                        next_url = self.request.full_url()</span><br><span class="line">                    else:</span><br><span class="line">                        next_url = self.request.uri</span><br><span class="line">                    url += &quot;?&quot; + urlencode(dict(next=next_url))</span><br><span class="line">                self.redirect(url)</span><br><span class="line">                return</span><br><span class="line">            raise HTTPError(403)</span><br><span class="line">        return method(self, *args, **kwargs)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>method(self,<em>args,*</em>kwargs)即为要装饰的函数。但是如果 像上面定义的post方法 async def post(self, <em>args, *</em>kwargs),作为一个协程函数，就不能再使用这个装饰器了，就需要改写一下这个装饰器。def authenticated_async(method):</p><p>初始化app的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import tornado</span><br><span class="line">from peewee_async import Manager</span><br><span class="line"></span><br><span class="line">from YourApp.urls import urlpattern</span><br><span class="line">from YourApp.settings import settings, database</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    #集成json到wtforms</span><br><span class="line">    import wtforms_json</span><br><span class="line">    wtforms_json.init()</span><br><span class="line"></span><br><span class="line">    app = web.Application(urlpattern, debug=True, **settings)</span><br><span class="line">    app.listen(80)</span><br><span class="line"></span><br><span class="line">    objects = Manager(database)</span><br><span class="line">    database.set_allow_sync(False)</span><br><span class="line">    app.objects = objects</span><br><span class="line"></span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>登陆装饰器改写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@functools.wraps(method)</span><br><span class="line">async def wrapper(self, *args, **kwargs):</span><br><span class="line">    tsessionid = self.request.headers.get(&quot;tsessionid&quot;, None)</span><br><span class="line">    if tsessionid:</span><br><span class="line">        try:</span><br><span class="line"></span><br><span class="line">            send_data = jwt.decode(tsessionid, self.settings[&quot;secret_key&quot;], leeway=self.settings[&quot;jwt_expire&quot;], options=&#123;&quot;verify_exp&quot;: True&#125;)</span><br><span class="line">            user_id = send_data[&quot;id&quot;]</span><br><span class="line">            # User 的model类，根据实际情况调整</span><br><span class="line">            #从数据库中获取到user并设置给_current_user</span><br><span class="line">            try:</span><br><span class="line">                user = await self.application.objects.get(User, id=user_id)</span><br><span class="line">                self._current_user = user</span><br><span class="line"></span><br><span class="line">                # 协程的调用方式</span><br><span class="line">                await method(self, *args, **kwargs)</span><br><span class="line">            except User.DoesNotExist as e:</span><br><span class="line">                self.set_status(401)</span><br><span class="line">        except jwt.ExpiredSignatureError as e: # 验证jwt 是否过期</span><br><span class="line">            self.set_status(401)</span><br><span class="line">    else:</span><br><span class="line">        self.set_status(401)</span><br><span class="line">    self.finish(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">return wrapper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado作为鼎鼎大名的web异步框架，用来作为高性能服务器以及web框架都是首选。自从python3.4加入了asyncio原生协程后，tornado的最新版本也开始使用了原生的协程。定义协程函数的时候就很简单了，也可以像sanic一样使用async def了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="后端" scheme="http://yoursite.com/categories/python/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>shadowsocks源码解读</title>
    <link href="http://yoursite.com/2019/07/20/shadowsockts%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/07/20/shadowsockts源码解读/</id>
    <published>2019-07-20T04:00:40.000Z</published>
    <updated>2019-11-04T17:15:57.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shadowsocks源码解读"><a href="#shadowsocks源码解读" class="headerlink" title="shadowsocks源码解读"></a>shadowsocks源码解读</h2><p>经常使用shadowsocks科学上网，但是一直没有时间去看一看人家怎么写的。<br>先记录一下一篇写的很详细的博客，这篇就当书签用啦。<br><a href="https://loggerhead.me/posts/shadowsocks-yuan-ma-fen-xi-xie-yi-yu-jie-gou.html" target="_blank" rel="noopener">Shadowsocks 源码分析——协议与结构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;shadowsocks源码解读&quot;&gt;&lt;a href=&quot;#shadowsocks源码解读&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks源码解读&quot;&gt;&lt;/a&gt;shadowsocks源码解读&lt;/h2&gt;&lt;p&gt;经常使用shadowsocks科学上
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>queue.Queue 和mutiprocessing.Queue</title>
    <link href="http://yoursite.com/2019/06/17/queue-Queue%20and%20multiprocessing-Queue/"/>
    <id>http://yoursite.com/2019/06/17/queue-Queue and multiprocessing-Queue/</id>
    <published>2019-06-17T03:09:40.000Z</published>
    <updated>2019-11-04T17:18:24.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这两个队列到底有什么不一样，又分别能在什么场景下使用呢"><a href="#这两个队列到底有什么不一样，又分别能在什么场景下使用呢" class="headerlink" title="这两个队列到底有什么不一样，又分别能在什么场景下使用呢?"></a>这两个队列到底有什么不一样，又分别能在什么场景下使用呢?</h2><p>queue.Queue只是一个内存队列，在多线程下使用。如果错误得用在了多进程中，那么每个进程都会创建一个Queue的实例,<br>因为进程不再共享<a id="more"></a>相同的内存。<br>也就是仅当生产者和消费者处于同一进程中时，这个Queue才能达到预期的效果。<br>看一下queue.Queue的初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, maxsize=0):</span><br><span class="line">    self.maxsize = maxsize</span><br><span class="line">    self._init(maxsize)</span><br><span class="line"></span><br><span class="line">    # mutex must be held whenever the queue is mutating.  All methods</span><br><span class="line">    # that acquire mutex must release it before returning.  mutex</span><br><span class="line">    # is shared between the three conditions, so acquiring and</span><br><span class="line">    # releasing the conditions also acquires and releases mutex.</span><br><span class="line">    self.mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line">    # Notify not_empty whenever an item is added to the queue; a</span><br><span class="line">    # thread waiting to get is notified then.</span><br><span class="line">    self.not_empty = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    # Notify not_full whenever an item is removed from the queue;</span><br><span class="line">    # a thread waiting to put is notified then.</span><br><span class="line">    self.not_full = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    # Notify all_tasks_done whenever the number of unfinished tasks</span><br><span class="line">    # drops to zero; thread waiting to join() is notified to resume</span><br><span class="line">    self.all_tasks_done = threading.Condition(self.mutex)</span><br><span class="line">    self.unfinished_tasks = 0</span><br></pre></td></tr></table></figure><p>在多进程应用场景中，如果多个进程需要共享数据，那么就不能使用queue.Queue了。<br>而应该使用可以共享内存的管道或套接字，也可以是其他东西-multiprocessing.Queue。它使用管道为两个进程进行通信提供一种方式。而这两个Queue又<br>恰好实现了与相同的API，因为大多数Python程序员已经非常熟悉它。</p><p>下面一段代码在Windows环境下会报错 <code>TypeError: can&#39;t pickle _thread.lock objects</code>：<br>进程池内部处理使用了pickle模块用于python特有的类型和python的数据类型间进行转换。<br>pickle模块要对内部的成员变量进行序列化，但不支持对自定义对象加锁，所以会抛出类型异常的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool, Process,Queue,JoinableQueue</span><br><span class="line">import os, time</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">def write(q): </span><br><span class="line">    for v in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: </span><br><span class="line">        print(&apos;Put %s to queue &apos; % v)</span><br><span class="line">        q.put_nowait(v) </span><br><span class="line">        time.sleep(0.2) </span><br><span class="line"></span><br><span class="line">def read(q): </span><br><span class="line">    while 1: </span><br><span class="line">        if not q.empty(): </span><br><span class="line">            v = q.get(True) </span><br><span class="line">            print(&quot;Get %s from queue&quot; % v)</span><br><span class="line">            time.sleep(0.2) </span><br><span class="line">        else: </span><br><span class="line">            break </span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;: </span><br><span class="line">    q = Queue() </span><br><span class="line">    pw = Process(target=write, args=(q, )) </span><br><span class="line">    pr = Process(target=read, args=(q, )) </span><br><span class="line">    pw.start() </span><br><span class="line">    pw.join() </span><br><span class="line"></span><br><span class="line">    pr.start() </span><br><span class="line">    pr.join() </span><br><span class="line"></span><br><span class="line">    print(&quot;all done...&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这两个队列到底有什么不一样，又分别能在什么场景下使用呢&quot;&gt;&lt;a href=&quot;#这两个队列到底有什么不一样，又分别能在什么场景下使用呢&quot; class=&quot;headerlink&quot; title=&quot;这两个队列到底有什么不一样，又分别能在什么场景下使用呢?&quot;&gt;&lt;/a&gt;这两个队列到底有什么不一样，又分别能在什么场景下使用呢?&lt;/h2&gt;&lt;p&gt;queue.Queue只是一个内存队列，在多线程下使用。如果错误得用在了多进程中，那么每个进程都会创建一个Queue的实例,&lt;br&gt;因为进程不再共享
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
